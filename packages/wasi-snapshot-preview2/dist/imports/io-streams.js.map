{"version":3,"file":"io-streams.js","sourceRoot":"","sources":["../../src/imports/io-streams.ts"],"names":[],"mappings":"","sourcesContent":["export interface IoStreams {\n  /**\n   * Read bytes from a stream.\n   * \n   * This function returns a list of bytes containing the data that was\n   * read, along with a bool which, when true, indicates that the end of the\n   * stream was reached. The returned list will contain up to `len` bytes; it\n   * may return fewer than requested, but not more.\n   * \n   * Once a stream has reached the end, subsequent calls to read or\n   * `skip` will always report end-of-stream rather than producing more\n   * data.\n   * \n   * If `len` is 0, it represents a request to read 0 bytes, which should\n   * always succeed, assuming the stream hasn't reached its end yet, and\n   * return an empty list.\n   * \n   * The len here is a `u64`, but some callees may not be able to allocate\n   * a buffer as large as that would imply.\n   * FIXME: describe what happens if allocation fails.\n   */\n   read(this0: InputStream, len: bigint): [Uint8Array | ArrayBuffer, boolean];\n  /**\n   * Read bytes from a stream, with blocking.\n   * \n   * This is similar to `read`, except that it blocks until at least one\n   * byte can be read.\n   */\n   blockingRead(this0: InputStream, len: bigint): [Uint8Array | ArrayBuffer, boolean];\n  /**\n   * Skip bytes from a stream.\n   * \n   * This is similar to the `read` function, but avoids copying the\n   * bytes into the instance.\n   * \n   * Once a stream has reached the end, subsequent calls to read or\n   * `skip` will always report end-of-stream rather than producing more\n   * data.\n   * \n   * This function returns the number of bytes skipped, along with a bool\n   * indicating whether the end of the stream was reached. The returned\n   * value will be at most `len`; it may be less.\n   */\n   skip(this0: InputStream, len: bigint): [bigint, boolean];\n  /**\n   * Skip bytes from a stream, with blocking.\n   * \n   * This is similar to `skip`, except that it blocks until at least one\n   * byte can be consumed.\n   */\n   blockingSkip(this0: InputStream, len: bigint): [bigint, boolean];\n  /**\n   * Create a `pollable` which will resolve once either the specified stream\n   * has bytes available to read or the other end of the stream has been\n   * closed.\n   */\n   subscribeToInputStream(this0: InputStream): Pollable;\n  /**\n   * Dispose of the specified `input-stream`, after which it may no longer\n   * be used.\n   */\n   dropInputStream(this0: InputStream): void;\n  /**\n   * Write bytes to a stream.\n   * \n   * This function returns a `u64` indicating the number of bytes from\n   * `buf` that were written; it may be less than the full list.\n   */\n   write(this0: OutputStream, buf: Uint8Array): bigint;\n  /**\n   * Write bytes to a stream, with blocking.\n   * \n   * This is similar to `write`, except that it blocks until at least one\n   * byte can be written.\n   */\n   blockingWrite(this0: OutputStream, buf: Uint8Array): bigint;\n  /**\n   * Write multiple zero bytes to a stream.\n   * \n   * This function returns a `u64` indicating the number of zero bytes\n   * that were written; it may be less than `len`.\n   */\n   writeZeroes(this0: OutputStream, len: bigint): bigint;\n  /**\n   * Write multiple zero bytes to a stream, with blocking.\n   * \n   * This is similar to `write-zeroes`, except that it blocks until at least\n   * one byte can be written.\n   */\n   blockingWriteZeroes(this0: OutputStream, len: bigint): bigint;\n  /**\n   * Read from one stream and write to another.\n   * \n   * This function returns the number of bytes transferred; it may be less\n   * than `len`.\n   * \n   * Unlike other I/O functions, this function blocks until all the data\n   * read from the input stream has been written to the output stream.\n   */\n   splice(this0: OutputStream, src: InputStream, len: bigint): [bigint, boolean];\n  /**\n   * Read from one stream and write to another, with blocking.\n   * \n   * This is similar to `splice`, except that it blocks until at least\n   * one byte can be read.\n   */\n   blockingSplice(this0: OutputStream, src: InputStream, len: bigint): [bigint, boolean];\n  /**\n   * Forward the entire contents of an input stream to an output stream.\n   * \n   * This function repeatedly reads from the input stream and writes\n   * the data to the output stream, until the end of the input stream\n   * is reached, or an error is encountered.\n   * \n   * Unlike other I/O functions, this function blocks until the end\n   * of the input stream is seen and all the data has been written to\n   * the output stream.\n   * \n   * This function returns the number of bytes transferred.\n   */\n   forward(this0: OutputStream, src: InputStream): bigint;\n  /**\n   * Create a `pollable` which will resolve once either the specified stream\n   * is ready to accept bytes or the other end of the stream has been closed.\n   */\n   subscribeToOutputStream(this0: OutputStream): Pollable;\n  /**\n   * Dispose of the specified `output-stream`, after which it may no longer\n   * be used.\n   */\n   dropOutputStream(this0: OutputStream): void;\n}\nexport interface IoStreamsAsync {\n  /**\n   * Read bytes from a stream.\n   * \n   * This function returns a list of bytes containing the data that was\n   * read, along with a bool which, when true, indicates that the end of the\n   * stream was reached. The returned list will contain up to `len` bytes; it\n   * may return fewer than requested, but not more.\n   * \n   * Once a stream has reached the end, subsequent calls to read or\n   * `skip` will always report end-of-stream rather than producing more\n   * data.\n   * \n   * If `len` is 0, it represents a request to read 0 bytes, which should\n   * always succeed, assuming the stream hasn't reached its end yet, and\n   * return an empty list.\n   * \n   * The len here is a `u64`, but some callees may not be able to allocate\n   * a buffer as large as that would imply.\n   * FIXME: describe what happens if allocation fails.\n   */\n   read(this0: InputStream, len: bigint): Promise<[Uint8Array | ArrayBuffer, boolean]>;\n  /**\n   * Read bytes from a stream, with blocking.\n   * \n   * This is similar to `read`, except that it blocks until at least one\n   * byte can be read.\n   */\n   blockingRead(this0: InputStream, len: bigint): Promise<[Uint8Array | ArrayBuffer, boolean]>;\n  /**\n   * Skip bytes from a stream.\n   * \n   * This is similar to the `read` function, but avoids copying the\n   * bytes into the instance.\n   * \n   * Once a stream has reached the end, subsequent calls to read or\n   * `skip` will always report end-of-stream rather than producing more\n   * data.\n   * \n   * This function returns the number of bytes skipped, along with a bool\n   * indicating whether the end of the stream was reached. The returned\n   * value will be at most `len`; it may be less.\n   */\n   skip(this0: InputStream, len: bigint): Promise<[bigint, boolean]>;\n  /**\n   * Skip bytes from a stream, with blocking.\n   * \n   * This is similar to `skip`, except that it blocks until at least one\n   * byte can be consumed.\n   */\n   blockingSkip(this0: InputStream, len: bigint): Promise<[bigint, boolean]>;\n  /**\n   * Create a `pollable` which will resolve once either the specified stream\n   * has bytes available to read or the other end of the stream has been\n   * closed.\n   */\n   subscribeToInputStream(this0: InputStream): Promise<Pollable>;\n  /**\n   * Dispose of the specified `input-stream`, after which it may no longer\n   * be used.\n   */\n   dropInputStream(this0: InputStream): Promise<void>;\n  /**\n   * Write bytes to a stream.\n   * \n   * This function returns a `u64` indicating the number of bytes from\n   * `buf` that were written; it may be less than the full list.\n   */\n   write(this0: OutputStream, buf: Uint8Array): Promise<bigint>;\n  /**\n   * Write bytes to a stream, with blocking.\n   * \n   * This is similar to `write`, except that it blocks until at least one\n   * byte can be written.\n   */\n   blockingWrite(this0: OutputStream, buf: Uint8Array): Promise<bigint>;\n  /**\n   * Write multiple zero bytes to a stream.\n   * \n   * This function returns a `u64` indicating the number of zero bytes\n   * that were written; it may be less than `len`.\n   */\n   writeZeroes(this0: OutputStream, len: bigint): Promise<bigint>;\n  /**\n   * Write multiple zero bytes to a stream, with blocking.\n   * \n   * This is similar to `write-zeroes`, except that it blocks until at least\n   * one byte can be written.\n   */\n   blockingWriteZeroes(this0: OutputStream, len: bigint): Promise<bigint>;\n  /**\n   * Read from one stream and write to another.\n   * \n   * This function returns the number of bytes transferred; it may be less\n   * than `len`.\n   * \n   * Unlike other I/O functions, this function blocks until all the data\n   * read from the input stream has been written to the output stream.\n   */\n   splice(this0: OutputStream, src: InputStream, len: bigint): Promise<[bigint, boolean]>;\n  /**\n   * Read from one stream and write to another, with blocking.\n   * \n   * This is similar to `splice`, except that it blocks until at least\n   * one byte can be read.\n   */\n   blockingSplice(this0: OutputStream, src: InputStream, len: bigint): Promise<[bigint, boolean]>;\n  /**\n   * Forward the entire contents of an input stream to an output stream.\n   * \n   * This function repeatedly reads from the input stream and writes\n   * the data to the output stream, until the end of the input stream\n   * is reached, or an error is encountered.\n   * \n   * Unlike other I/O functions, this function blocks until the end\n   * of the input stream is seen and all the data has been written to\n   * the output stream.\n   * \n   * This function returns the number of bytes transferred.\n   */\n   forward(this0: OutputStream, src: InputStream): Promise<bigint>;\n  /**\n   * Create a `pollable` which will resolve once either the specified stream\n   * is ready to accept bytes or the other end of the stream has been closed.\n   */\n   subscribeToOutputStream(this0: OutputStream): Promise<Pollable>;\n  /**\n   * Dispose of the specified `output-stream`, after which it may no longer\n   * be used.\n   */\n   dropOutputStream(this0: OutputStream): Promise<void>;\n}\nimport type { Pollable } from '../imports/poll-poll';\nexport { Pollable };\n/**\n * An error type returned from a stream operation. Currently this\n * doesn't provide any additional information.\n */\nexport interface StreamError {\n}\n/**\n * An output bytestream. In the future, this will be replaced by handle\n * types.\n * \n * This conceptually represents a `stream<u8, _>`. It's temporary\n * scaffolding until component-model's async features are ready.\n * \n * `output-stream`s are *non-blocking* to the extent practical on\n * underlying platforms. Except where specified otherwise, I/O operations also\n * always return promptly, after the number of bytes that can be written\n * promptly, which could even be zero. To wait for the stream to be ready to\n * accept data, the `subscribe-to-output-stream` function to obtain a\n * `pollable` which can be polled for using `wasi_poll`.\n * \n * And at present, it is a `u32` instead of being an actual handle, until\n * the wit-bindgen implementation of handles and resources is ready.\n * \n * This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).\n */\nexport type OutputStream = number;\n/**\n * An input bytestream. In the future, this will be replaced by handle\n * types.\n * \n * This conceptually represents a `stream<u8, _>`. It's temporary\n * scaffolding until component-model's async features are ready.\n * \n * `input-stream`s are *non-blocking* to the extent practical on underlying\n * platforms. I/O operations always return promptly; if fewer bytes are\n * promptly available than requested, they return the number of bytes promptly\n * available, which could even be zero. To wait for data to be available,\n * use the `subscribe-to-input-stream` function to obtain a `pollable` which\n * can be polled for using `wasi_poll`.\n * \n * And at present, it is a `u32` instead of being an actual handle, until\n * the wit-bindgen implementation of handles and resources is ready.\n * \n * This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).\n */\nexport type InputStream = number;\n"]}