{"version":3,"file":"poll-poll.js","sourceRoot":"","sources":["../../src/imports/poll-poll.ts"],"names":[],"mappings":"","sourcesContent":["export interface PollPoll {\n  /**\n   * Dispose of the specified `pollable`, after which it may no longer\n   * be used.\n   */\n   dropPollable(this0: Pollable): void;\n  /**\n   * Poll for completion on a set of pollables.\n   * \n   * The \"oneoff\" in the name refers to the fact that this function must do a\n   * linear scan through the entire list of subscriptions, which may be\n   * inefficient if the number is large and the same subscriptions are used\n   * many times. In the future, this is expected to be obsoleted by the\n   * component model async proposal, which will include a scalable waiting\n   * facility.\n   * \n   * Note that the return type would ideally be `list<bool>`, but that would\n   * be more difficult to polyfill given the current state of `wit-bindgen`.\n   * See <https://github.com/bytecodealliance/preview2-prototyping/pull/11#issuecomment-1329873061>\n   * for details.  For now, we use zero to mean \"not ready\" and non-zero to\n   * mean \"ready\".\n   */\n   pollOneoff(in0: Uint32Array): Uint8Array | ArrayBuffer;\n}\nexport interface PollPollAsync {\n  /**\n   * Dispose of the specified `pollable`, after which it may no longer\n   * be used.\n   */\n   dropPollable(this0: Pollable): Promise<void>;\n  /**\n   * Poll for completion on a set of pollables.\n   * \n   * The \"oneoff\" in the name refers to the fact that this function must do a\n   * linear scan through the entire list of subscriptions, which may be\n   * inefficient if the number is large and the same subscriptions are used\n   * many times. In the future, this is expected to be obsoleted by the\n   * component model async proposal, which will include a scalable waiting\n   * facility.\n   * \n   * Note that the return type would ideally be `list<bool>`, but that would\n   * be more difficult to polyfill given the current state of `wit-bindgen`.\n   * See <https://github.com/bytecodealliance/preview2-prototyping/pull/11#issuecomment-1329873061>\n   * for details.  For now, we use zero to mean \"not ready\" and non-zero to\n   * mean \"ready\".\n   */\n   pollOneoff(in0: Uint32Array): Promise<Uint8Array | ArrayBuffer>;\n}\n/**\n * A \"pollable\" handle.\n * \n * This is conceptually represents a `stream<_, _>`, or in other words,\n * a stream that one can wait on, repeatedly, but which does not itself\n * produce any data. It's temporary scaffolding until component-model's\n * async features are ready.\n * \n * And at present, it is a `u32` instead of being an actual handle, until\n * the wit-bindgen implementation of handles and resources is ready.\n * \n * `pollable` lifetimes are not automatically managed. Users must ensure\n * that they do not outlive the resource they reference.\n * \n * This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).\n */\nexport type Pollable = number;\n"]}