{"version":3,"file":"filesystem-filesystem.js","sourceRoot":"","sources":["../../src/imports/filesystem-filesystem.ts"],"names":[],"mappings":"","sourcesContent":["export interface FilesystemFilesystem {\n  /**\n   * Return a stream for reading from a file.\n   * \n   * Multiple read, write, and append streams may be active on the same open\n   * file and they do not interfere with each other.\n   * \n   * Note: This allows using `wasi:io/streams.read`, which is similar to `read` in POSIX.\n   */\n   readViaStream(this0: Descriptor, offset: Filesize): InputStream;\n  /**\n   * Return a stream for writing to a file.\n   * \n   * Note: This allows using `wasi:io/streams.write`, which is similar to `write` in\n   * POSIX.\n   */\n   writeViaStream(this0: Descriptor, offset: Filesize): OutputStream;\n  /**\n   * Return a stream for appending to a file.\n   * \n   * Note: This allows using `wasi:io/streams.write`, which is similar to `write` with\n   * `O_APPEND` in in POSIX.\n   */\n   appendViaStream(this0: Descriptor): OutputStream;\n  /**\n   * Provide file advisory information on a descriptor.\n   * \n   * This is similar to `posix_fadvise` in POSIX.\n   */\n   advise(this0: Descriptor, offset: Filesize, length: Filesize, advice: Advice): void;\n  /**\n   * Synchronize the data of a file to disk.\n   * \n   * This function succeeds with no effect if the file descriptor is not\n   * opened for writing.\n   * \n   * Note: This is similar to `fdatasync` in POSIX.\n   */\n   syncData(this0: Descriptor): void;\n  /**\n   * Get flags associated with a descriptor.\n   * \n   * Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.\n   * \n   * Note: This returns the value that was the `fs_flags` value returned\n   * from `fdstat_get` in earlier versions of WASI.\n   */\n   getFlags(this0: Descriptor): DescriptorFlags;\n  /**\n   * Get the dynamic type of a descriptor.\n   * \n   * Note: This returns the same value as the `type` field of the `fd-stat`\n   * returned by `stat`, `stat-at` and similar.\n   * \n   * Note: This returns similar flags to the `st_mode & S_IFMT` value provided\n   * by `fstat` in POSIX.\n   * \n   * Note: This returns the value that was the `fs_filetype` value returned\n   * from `fdstat_get` in earlier versions of WASI.\n   */\n   getType(this0: Descriptor): DescriptorType;\n  /**\n   * Adjust the size of an open file. If this increases the file's size, the\n   * extra bytes are filled with zeros.\n   * \n   * Note: This was called `fd_filestat_set_size` in earlier versions of WASI.\n   */\n   setSize(this0: Descriptor, size: Filesize): void;\n  /**\n   * Adjust the timestamps of an open file or directory.\n   * \n   * Note: This is similar to `futimens` in POSIX.\n   * \n   * Note: This was called `fd_filestat_set_times` in earlier versions of WASI.\n   */\n   setTimes(this0: Descriptor, dataAccessTimestamp: NewTimestamp, dataModificationTimestamp: NewTimestamp): void;\n  /**\n   * Read from a descriptor, without using and updating the descriptor's offset.\n   * \n   * This function returns a list of bytes containing the data that was\n   * read, along with a bool which, when true, indicates that the end of the\n   * file was reached. The returned list will contain up to `length` bytes; it\n   * may return fewer than requested, if the end of the file is reached or\n   * if the I/O operation is interrupted.\n   * \n   * In the future, this may change to return a `stream<u8, error-code>`.\n   * \n   * Note: This is similar to `pread` in POSIX.\n   */\n   read(this0: Descriptor, length: Filesize, offset: Filesize): [Uint8Array | ArrayBuffer, boolean];\n  /**\n   * Write to a descriptor, without using and updating the descriptor's offset.\n   * \n   * It is valid to write past the end of a file; the file is extended to the\n   * extent of the write, with bytes between the previous end and the start of\n   * the write set to zero.\n   * \n   * In the future, this may change to take a `stream<u8, error-code>`.\n   * \n   * Note: This is similar to `pwrite` in POSIX.\n   */\n   write(this0: Descriptor, buffer: Uint8Array, offset: Filesize): Filesize;\n  /**\n   * Read directory entries from a directory.\n   * \n   * On filesystems where directories contain entries referring to themselves\n   * and their parents, often named `.` and `..` respectively, these entries\n   * are omitted.\n   * \n   * This always returns a new stream which starts at the beginning of the\n   * directory. Multiple streams may be active on the same directory, and they\n   * do not interfere with each other.\n   */\n   readDirectory(this0: Descriptor): DirectoryEntryStream;\n  /**\n   * Synchronize the data and metadata of a file to disk.\n   * \n   * This function succeeds with no effect if the file descriptor is not\n   * opened for writing.\n   * \n   * Note: This is similar to `fsync` in POSIX.\n   */\n   sync(this0: Descriptor): void;\n  /**\n   * Create a directory.\n   * \n   * Note: This is similar to `mkdirat` in POSIX.\n   */\n   createDirectoryAt(this0: Descriptor, path: string): void;\n  /**\n   * Return the attributes of an open file or directory.\n   * \n   * Note: This is similar to `fstat` in POSIX.\n   * \n   * Note: This was called `fd_filestat_get` in earlier versions of WASI.\n   */\n   stat(this0: Descriptor): DescriptorStat;\n  /**\n   * Return the attributes of a file or directory.\n   * \n   * Note: This is similar to `fstatat` in POSIX.\n   * \n   * Note: This was called `path_filestat_get` in earlier versions of WASI.\n   */\n   statAt(this0: Descriptor, pathFlags: PathFlags, path: string): DescriptorStat;\n  /**\n   * Adjust the timestamps of a file or directory.\n   * \n   * Note: This is similar to `utimensat` in POSIX.\n   * \n   * Note: This was called `path_filestat_set_times` in earlier versions of\n   * WASI.\n   */\n   setTimesAt(this0: Descriptor, pathFlags: PathFlags, path: string, dataAccessTimestamp: NewTimestamp, dataModificationTimestamp: NewTimestamp): void;\n  /**\n   * Create a hard link.\n   * \n   * Note: This is similar to `linkat` in POSIX.\n   */\n   linkAt(this0: Descriptor, oldPathFlags: PathFlags, oldPath: string, newDescriptor: Descriptor, newPath: string): void;\n  /**\n   * Open a file or directory.\n   * \n   * The returned descriptor is not guaranteed to be the lowest-numbered\n   * descriptor not currently open/ it is randomized to prevent applications\n   * from depending on making assumptions about indexes, since this is\n   * error-prone in multi-threaded contexts. The returned descriptor is\n   * guaranteed to be less than 2**31.\n   * \n   * If `flags` contains `descriptor-flags::mutate-directory`, and the base\n   * descriptor doesn't have `descriptor-flags::mutate-directory` set,\n   * `open-at` fails with `error-code::read-only`.\n   * \n   * If `flags` contains `write` or `mutate-directory`, or `open-flags`\n   * contains `truncate` or `create`, and the base descriptor doesn't have\n   * `descriptor-flags::mutate-directory` set, `open-at` fails with\n   * `error-code::read-only`.\n   * \n   * Note: This is similar to `openat` in POSIX.\n   */\n   openAt(this0: Descriptor, pathFlags: PathFlags, path: string, openFlags: OpenFlags, flags: DescriptorFlags, modes: Modes): Descriptor;\n  /**\n   * Read the contents of a symbolic link.\n   * \n   * If the contents contain an absolute or rooted path in the underlying\n   * filesystem, this function fails with `error-code::not-permitted`.\n   * \n   * Note: This is similar to `readlinkat` in POSIX.\n   */\n   readlinkAt(this0: Descriptor, path: string): string;\n  /**\n   * Remove a directory.\n   * \n   * Return `error-code::not-empty` if the directory is not empty.\n   * \n   * Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.\n   */\n   removeDirectoryAt(this0: Descriptor, path: string): void;\n  /**\n   * Rename a filesystem object.\n   * \n   * Note: This is similar to `renameat` in POSIX.\n   */\n   renameAt(this0: Descriptor, oldPath: string, newDescriptor: Descriptor, newPath: string): void;\n  /**\n   * Create a symbolic link (also known as a \"symlink\").\n   * \n   * If `old-path` starts with `/`, the function fails with\n   * `error-code::not-permitted`.\n   * \n   * Note: This is similar to `symlinkat` in POSIX.\n   */\n   symlinkAt(this0: Descriptor, oldPath: string, newPath: string): void;\n  /**\n   * Check accessibility of a filesystem path.\n   * \n   * Check whether the given filesystem path names an object which is\n   * readable, writable, or executable, or whether it exists.\n   * \n   * This does not a guarantee that subsequent accesses will succeed, as\n   * filesystem permissions may be modified asynchronously by external\n   * entities.\n   * \n   * Note: This is similar to `faccessat` with the `AT_EACCESS` flag in POSIX.\n   */\n   accessAt(this0: Descriptor, pathFlags: PathFlags, path: string, type: AccessType): void;\n  /**\n   * Unlink a filesystem object that is not a directory.\n   * \n   * Return `error-code::is-directory` if the path refers to a directory.\n   * Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.\n   */\n   unlinkFileAt(this0: Descriptor, path: string): void;\n  /**\n   * Change the permissions of a filesystem object that is not a directory.\n   * \n   * Note that the ultimate meanings of these permissions is\n   * filesystem-specific.\n   * \n   * Note: This is similar to `fchmodat` in POSIX.\n   */\n   changeFilePermissionsAt(this0: Descriptor, pathFlags: PathFlags, path: string, modes: Modes): void;\n  /**\n   * Change the permissions of a directory.\n   * \n   * Note that the ultimate meanings of these permissions is\n   * filesystem-specific.\n   * \n   * Unlike in POSIX, the `executable` flag is not reinterpreted as a \"search\"\n   * flag. `read` on a directory implies readability and searchability, and\n   * `execute` is not valid for directories.\n   * \n   * Note: This is similar to `fchmodat` in POSIX.\n   */\n   changeDirectoryPermissionsAt(this0: Descriptor, pathFlags: PathFlags, path: string, modes: Modes): void;\n  /**\n   * Request a shared advisory lock for an open file.\n   * \n   * This requests a *shared* lock; more than one shared lock can be held for\n   * a file at the same time.\n   * \n   * If the open file has an exclusive lock, this function downgrades the lock\n   * to a shared lock. If it has a shared lock, this function has no effect.\n   * \n   * This requests an *advisory* lock, meaning that the file could be accessed\n   * by other programs that don't hold the lock.\n   * \n   * It is unspecified how shared locks interact with locks acquired by\n   * non-WASI programs.\n   * \n   * This function blocks until the lock can be acquired.\n   * \n   * Not all filesystems support locking; on filesystems which don't support\n   * locking, this function returns `error-code::unsupported`.\n   * \n   * Note: This is similar to `flock(fd, LOCK_SH)` in Unix.\n   */\n   lockShared(this0: Descriptor): void;\n  /**\n   * Request an exclusive advisory lock for an open file.\n   * \n   * This requests an *exclusive* lock; no other locks may be held for the\n   * file while an exclusive lock is held.\n   * \n   * If the open file has a shared lock and there are no exclusive locks held\n   * for the file, this function upgrades the lock to an exclusive lock. If the\n   * open file already has an exclusive lock, this function has no effect.\n   * \n   * This requests an *advisory* lock, meaning that the file could be accessed\n   * by other programs that don't hold the lock.\n   * \n   * It is unspecified whether this function succeeds if the file descriptor\n   * is not opened for writing. It is unspecified how exclusive locks interact\n   * with locks acquired by non-WASI programs.\n   * \n   * This function blocks until the lock can be acquired.\n   * \n   * Not all filesystems support locking; on filesystems which don't support\n   * locking, this function returns `error-code::unsupported`.\n   * \n   * Note: This is similar to `flock(fd, LOCK_EX)` in Unix.\n   */\n   lockExclusive(this0: Descriptor): void;\n  /**\n   * Request a shared advisory lock for an open file.\n   * \n   * This requests a *shared* lock; more than one shared lock can be held for\n   * a file at the same time.\n   * \n   * If the open file has an exclusive lock, this function downgrades the lock\n   * to a shared lock. If it has a shared lock, this function has no effect.\n   * \n   * This requests an *advisory* lock, meaning that the file could be accessed\n   * by other programs that don't hold the lock.\n   * \n   * It is unspecified how shared locks interact with locks acquired by\n   * non-WASI programs.\n   * \n   * This function returns `error-code::would-block` if the lock cannot be\n   * acquired.\n   * \n   * Not all filesystems support locking; on filesystems which don't support\n   * locking, this function returns `error-code::unsupported`.\n   * \n   * Note: This is similar to `flock(fd, LOCK_SH | LOCK_NB)` in Unix.\n   */\n   tryLockShared(this0: Descriptor): void;\n  /**\n   * Request an exclusive advisory lock for an open file.\n   * \n   * This requests an *exclusive* lock; no other locks may be held for the\n   * file while an exclusive lock is held.\n   * \n   * If the open file has a shared lock and there are no exclusive locks held\n   * for the file, this function upgrades the lock to an exclusive lock. If the\n   * open file already has an exclusive lock, this function has no effect.\n   * \n   * This requests an *advisory* lock, meaning that the file could be accessed\n   * by other programs that don't hold the lock.\n   * \n   * It is unspecified whether this function succeeds if the file descriptor\n   * is not opened for writing. It is unspecified how exclusive locks interact\n   * with locks acquired by non-WASI programs.\n   * \n   * This function returns `error-code::would-block` if the lock cannot be\n   * acquired.\n   * \n   * Not all filesystems support locking; on filesystems which don't support\n   * locking, this function returns `error-code::unsupported`.\n   * \n   * Note: This is similar to `flock(fd, LOCK_EX | LOCK_NB)` in Unix.\n   */\n   tryLockExclusive(this0: Descriptor): void;\n  /**\n   * Release a shared or exclusive lock on an open file.\n   * \n   * Note: This is similar to `flock(fd, LOCK_UN)` in Unix.\n   */\n   unlock(this0: Descriptor): void;\n  /**\n   * Dispose of the specified `descriptor`, after which it may no longer\n   * be used.\n   */\n   dropDescriptor(this0: Descriptor): void;\n  /**\n   * Read a single directory entry from a `directory-entry-stream`.\n   */\n   readDirectoryEntry(this0: DirectoryEntryStream): DirectoryEntry | null;\n  /**\n   * Dispose of the specified `directory-entry-stream`, after which it may no longer\n   * be used.\n   */\n   dropDirectoryEntryStream(this0: DirectoryEntryStream): void;\n}\nexport interface FilesystemFilesystemAsync {\n  /**\n   * Return a stream for reading from a file.\n   * \n   * Multiple read, write, and append streams may be active on the same open\n   * file and they do not interfere with each other.\n   * \n   * Note: This allows using `wasi:io/streams.read`, which is similar to `read` in POSIX.\n   */\n   readViaStream(this0: Descriptor, offset: Filesize): Promise<InputStream>;\n  /**\n   * Return a stream for writing to a file.\n   * \n   * Note: This allows using `wasi:io/streams.write`, which is similar to `write` in\n   * POSIX.\n   */\n   writeViaStream(this0: Descriptor, offset: Filesize): Promise<OutputStream>;\n  /**\n   * Return a stream for appending to a file.\n   * \n   * Note: This allows using `wasi:io/streams.write`, which is similar to `write` with\n   * `O_APPEND` in in POSIX.\n   */\n   appendViaStream(this0: Descriptor): Promise<OutputStream>;\n  /**\n   * Provide file advisory information on a descriptor.\n   * \n   * This is similar to `posix_fadvise` in POSIX.\n   */\n   advise(this0: Descriptor, offset: Filesize, length: Filesize, advice: Advice): Promise<void>;\n  /**\n   * Synchronize the data of a file to disk.\n   * \n   * This function succeeds with no effect if the file descriptor is not\n   * opened for writing.\n   * \n   * Note: This is similar to `fdatasync` in POSIX.\n   */\n   syncData(this0: Descriptor): Promise<void>;\n  /**\n   * Get flags associated with a descriptor.\n   * \n   * Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.\n   * \n   * Note: This returns the value that was the `fs_flags` value returned\n   * from `fdstat_get` in earlier versions of WASI.\n   */\n   getFlags(this0: Descriptor): Promise<DescriptorFlags>;\n  /**\n   * Get the dynamic type of a descriptor.\n   * \n   * Note: This returns the same value as the `type` field of the `fd-stat`\n   * returned by `stat`, `stat-at` and similar.\n   * \n   * Note: This returns similar flags to the `st_mode & S_IFMT` value provided\n   * by `fstat` in POSIX.\n   * \n   * Note: This returns the value that was the `fs_filetype` value returned\n   * from `fdstat_get` in earlier versions of WASI.\n   */\n   getType(this0: Descriptor): Promise<DescriptorType>;\n  /**\n   * Adjust the size of an open file. If this increases the file's size, the\n   * extra bytes are filled with zeros.\n   * \n   * Note: This was called `fd_filestat_set_size` in earlier versions of WASI.\n   */\n   setSize(this0: Descriptor, size: Filesize): Promise<void>;\n  /**\n   * Adjust the timestamps of an open file or directory.\n   * \n   * Note: This is similar to `futimens` in POSIX.\n   * \n   * Note: This was called `fd_filestat_set_times` in earlier versions of WASI.\n   */\n   setTimes(this0: Descriptor, dataAccessTimestamp: NewTimestamp, dataModificationTimestamp: NewTimestamp): Promise<void>;\n  /**\n   * Read from a descriptor, without using and updating the descriptor's offset.\n   * \n   * This function returns a list of bytes containing the data that was\n   * read, along with a bool which, when true, indicates that the end of the\n   * file was reached. The returned list will contain up to `length` bytes; it\n   * may return fewer than requested, if the end of the file is reached or\n   * if the I/O operation is interrupted.\n   * \n   * In the future, this may change to return a `stream<u8, error-code>`.\n   * \n   * Note: This is similar to `pread` in POSIX.\n   */\n   read(this0: Descriptor, length: Filesize, offset: Filesize): Promise<[Uint8Array | ArrayBuffer, boolean]>;\n  /**\n   * Write to a descriptor, without using and updating the descriptor's offset.\n   * \n   * It is valid to write past the end of a file; the file is extended to the\n   * extent of the write, with bytes between the previous end and the start of\n   * the write set to zero.\n   * \n   * In the future, this may change to take a `stream<u8, error-code>`.\n   * \n   * Note: This is similar to `pwrite` in POSIX.\n   */\n   write(this0: Descriptor, buffer: Uint8Array, offset: Filesize): Promise<Filesize>;\n  /**\n   * Read directory entries from a directory.\n   * \n   * On filesystems where directories contain entries referring to themselves\n   * and their parents, often named `.` and `..` respectively, these entries\n   * are omitted.\n   * \n   * This always returns a new stream which starts at the beginning of the\n   * directory. Multiple streams may be active on the same directory, and they\n   * do not interfere with each other.\n   */\n   readDirectory(this0: Descriptor): Promise<DirectoryEntryStream>;\n  /**\n   * Synchronize the data and metadata of a file to disk.\n   * \n   * This function succeeds with no effect if the file descriptor is not\n   * opened for writing.\n   * \n   * Note: This is similar to `fsync` in POSIX.\n   */\n   sync(this0: Descriptor): Promise<void>;\n  /**\n   * Create a directory.\n   * \n   * Note: This is similar to `mkdirat` in POSIX.\n   */\n   createDirectoryAt(this0: Descriptor, path: string): Promise<void>;\n  /**\n   * Return the attributes of an open file or directory.\n   * \n   * Note: This is similar to `fstat` in POSIX.\n   * \n   * Note: This was called `fd_filestat_get` in earlier versions of WASI.\n   */\n   stat(this0: Descriptor): Promise<DescriptorStat>;\n  /**\n   * Return the attributes of a file or directory.\n   * \n   * Note: This is similar to `fstatat` in POSIX.\n   * \n   * Note: This was called `path_filestat_get` in earlier versions of WASI.\n   */\n   statAt(this0: Descriptor, pathFlags: PathFlags, path: string): Promise<DescriptorStat>;\n  /**\n   * Adjust the timestamps of a file or directory.\n   * \n   * Note: This is similar to `utimensat` in POSIX.\n   * \n   * Note: This was called `path_filestat_set_times` in earlier versions of\n   * WASI.\n   */\n   setTimesAt(this0: Descriptor, pathFlags: PathFlags, path: string, dataAccessTimestamp: NewTimestamp, dataModificationTimestamp: NewTimestamp): Promise<void>;\n  /**\n   * Create a hard link.\n   * \n   * Note: This is similar to `linkat` in POSIX.\n   */\n   linkAt(this0: Descriptor, oldPathFlags: PathFlags, oldPath: string, newDescriptor: Descriptor, newPath: string): Promise<void>;\n  /**\n   * Open a file or directory.\n   * \n   * The returned descriptor is not guaranteed to be the lowest-numbered\n   * descriptor not currently open/ it is randomized to prevent applications\n   * from depending on making assumptions about indexes, since this is\n   * error-prone in multi-threaded contexts. The returned descriptor is\n   * guaranteed to be less than 2**31.\n   * \n   * If `flags` contains `descriptor-flags::mutate-directory`, and the base\n   * descriptor doesn't have `descriptor-flags::mutate-directory` set,\n   * `open-at` fails with `error-code::read-only`.\n   * \n   * If `flags` contains `write` or `mutate-directory`, or `open-flags`\n   * contains `truncate` or `create`, and the base descriptor doesn't have\n   * `descriptor-flags::mutate-directory` set, `open-at` fails with\n   * `error-code::read-only`.\n   * \n   * Note: This is similar to `openat` in POSIX.\n   */\n   openAt(this0: Descriptor, pathFlags: PathFlags, path: string, openFlags: OpenFlags, flags: DescriptorFlags, modes: Modes): Promise<Descriptor>;\n  /**\n   * Read the contents of a symbolic link.\n   * \n   * If the contents contain an absolute or rooted path in the underlying\n   * filesystem, this function fails with `error-code::not-permitted`.\n   * \n   * Note: This is similar to `readlinkat` in POSIX.\n   */\n   readlinkAt(this0: Descriptor, path: string): Promise<string>;\n  /**\n   * Remove a directory.\n   * \n   * Return `error-code::not-empty` if the directory is not empty.\n   * \n   * Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.\n   */\n   removeDirectoryAt(this0: Descriptor, path: string): Promise<void>;\n  /**\n   * Rename a filesystem object.\n   * \n   * Note: This is similar to `renameat` in POSIX.\n   */\n   renameAt(this0: Descriptor, oldPath: string, newDescriptor: Descriptor, newPath: string): Promise<void>;\n  /**\n   * Create a symbolic link (also known as a \"symlink\").\n   * \n   * If `old-path` starts with `/`, the function fails with\n   * `error-code::not-permitted`.\n   * \n   * Note: This is similar to `symlinkat` in POSIX.\n   */\n   symlinkAt(this0: Descriptor, oldPath: string, newPath: string): Promise<void>;\n  /**\n   * Check accessibility of a filesystem path.\n   * \n   * Check whether the given filesystem path names an object which is\n   * readable, writable, or executable, or whether it exists.\n   * \n   * This does not a guarantee that subsequent accesses will succeed, as\n   * filesystem permissions may be modified asynchronously by external\n   * entities.\n   * \n   * Note: This is similar to `faccessat` with the `AT_EACCESS` flag in POSIX.\n   */\n   accessAt(this0: Descriptor, pathFlags: PathFlags, path: string, type: AccessType): Promise<void>;\n  /**\n   * Unlink a filesystem object that is not a directory.\n   * \n   * Return `error-code::is-directory` if the path refers to a directory.\n   * Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.\n   */\n   unlinkFileAt(this0: Descriptor, path: string): Promise<void>;\n  /**\n   * Change the permissions of a filesystem object that is not a directory.\n   * \n   * Note that the ultimate meanings of these permissions is\n   * filesystem-specific.\n   * \n   * Note: This is similar to `fchmodat` in POSIX.\n   */\n   changeFilePermissionsAt(this0: Descriptor, pathFlags: PathFlags, path: string, modes: Modes): Promise<void>;\n  /**\n   * Change the permissions of a directory.\n   * \n   * Note that the ultimate meanings of these permissions is\n   * filesystem-specific.\n   * \n   * Unlike in POSIX, the `executable` flag is not reinterpreted as a \"search\"\n   * flag. `read` on a directory implies readability and searchability, and\n   * `execute` is not valid for directories.\n   * \n   * Note: This is similar to `fchmodat` in POSIX.\n   */\n   changeDirectoryPermissionsAt(this0: Descriptor, pathFlags: PathFlags, path: string, modes: Modes): Promise<void>;\n  /**\n   * Request a shared advisory lock for an open file.\n   * \n   * This requests a *shared* lock; more than one shared lock can be held for\n   * a file at the same time.\n   * \n   * If the open file has an exclusive lock, this function downgrades the lock\n   * to a shared lock. If it has a shared lock, this function has no effect.\n   * \n   * This requests an *advisory* lock, meaning that the file could be accessed\n   * by other programs that don't hold the lock.\n   * \n   * It is unspecified how shared locks interact with locks acquired by\n   * non-WASI programs.\n   * \n   * This function blocks until the lock can be acquired.\n   * \n   * Not all filesystems support locking; on filesystems which don't support\n   * locking, this function returns `error-code::unsupported`.\n   * \n   * Note: This is similar to `flock(fd, LOCK_SH)` in Unix.\n   */\n   lockShared(this0: Descriptor): Promise<void>;\n  /**\n   * Request an exclusive advisory lock for an open file.\n   * \n   * This requests an *exclusive* lock; no other locks may be held for the\n   * file while an exclusive lock is held.\n   * \n   * If the open file has a shared lock and there are no exclusive locks held\n   * for the file, this function upgrades the lock to an exclusive lock. If the\n   * open file already has an exclusive lock, this function has no effect.\n   * \n   * This requests an *advisory* lock, meaning that the file could be accessed\n   * by other programs that don't hold the lock.\n   * \n   * It is unspecified whether this function succeeds if the file descriptor\n   * is not opened for writing. It is unspecified how exclusive locks interact\n   * with locks acquired by non-WASI programs.\n   * \n   * This function blocks until the lock can be acquired.\n   * \n   * Not all filesystems support locking; on filesystems which don't support\n   * locking, this function returns `error-code::unsupported`.\n   * \n   * Note: This is similar to `flock(fd, LOCK_EX)` in Unix.\n   */\n   lockExclusive(this0: Descriptor): Promise<void>;\n  /**\n   * Request a shared advisory lock for an open file.\n   * \n   * This requests a *shared* lock; more than one shared lock can be held for\n   * a file at the same time.\n   * \n   * If the open file has an exclusive lock, this function downgrades the lock\n   * to a shared lock. If it has a shared lock, this function has no effect.\n   * \n   * This requests an *advisory* lock, meaning that the file could be accessed\n   * by other programs that don't hold the lock.\n   * \n   * It is unspecified how shared locks interact with locks acquired by\n   * non-WASI programs.\n   * \n   * This function returns `error-code::would-block` if the lock cannot be\n   * acquired.\n   * \n   * Not all filesystems support locking; on filesystems which don't support\n   * locking, this function returns `error-code::unsupported`.\n   * \n   * Note: This is similar to `flock(fd, LOCK_SH | LOCK_NB)` in Unix.\n   */\n   tryLockShared(this0: Descriptor): Promise<void>;\n  /**\n   * Request an exclusive advisory lock for an open file.\n   * \n   * This requests an *exclusive* lock; no other locks may be held for the\n   * file while an exclusive lock is held.\n   * \n   * If the open file has a shared lock and there are no exclusive locks held\n   * for the file, this function upgrades the lock to an exclusive lock. If the\n   * open file already has an exclusive lock, this function has no effect.\n   * \n   * This requests an *advisory* lock, meaning that the file could be accessed\n   * by other programs that don't hold the lock.\n   * \n   * It is unspecified whether this function succeeds if the file descriptor\n   * is not opened for writing. It is unspecified how exclusive locks interact\n   * with locks acquired by non-WASI programs.\n   * \n   * This function returns `error-code::would-block` if the lock cannot be\n   * acquired.\n   * \n   * Not all filesystems support locking; on filesystems which don't support\n   * locking, this function returns `error-code::unsupported`.\n   * \n   * Note: This is similar to `flock(fd, LOCK_EX | LOCK_NB)` in Unix.\n   */\n   tryLockExclusive(this0: Descriptor): Promise<void>;\n  /**\n   * Release a shared or exclusive lock on an open file.\n   * \n   * Note: This is similar to `flock(fd, LOCK_UN)` in Unix.\n   */\n   unlock(this0: Descriptor): Promise<void>;\n  /**\n   * Dispose of the specified `descriptor`, after which it may no longer\n   * be used.\n   */\n   dropDescriptor(this0: Descriptor): Promise<void>;\n  /**\n   * Read a single directory entry from a `directory-entry-stream`.\n   */\n   readDirectoryEntry(this0: DirectoryEntryStream): Promise<DirectoryEntry | null>;\n  /**\n   * Dispose of the specified `directory-entry-stream`, after which it may no longer\n   * be used.\n   */\n   dropDirectoryEntryStream(this0: DirectoryEntryStream): Promise<void>;\n}\nimport type { InputStream } from '../imports/io-streams';\nexport { InputStream };\nimport type { OutputStream } from '../imports/io-streams';\nexport { OutputStream };\nimport type { Datetime } from '../imports/clocks-wall-clock';\nexport { Datetime };\n/**\n * Flags determining the method of how paths are resolved.\n */\nexport interface PathFlags {\n  /**\n   * As long as the resolved path corresponds to a symbolic link, it is\n   * expanded.\n   */\n  symlinkFollow?: boolean,\n}\n/**\n * Open flags used by `open-at`.\n */\nexport interface OpenFlags {\n  /**\n   * Create file if it does not exist, similar to `O_CREAT` in POSIX.\n   */\n  create?: boolean,\n  /**\n   * Fail if not a directory, similar to `O_DIRECTORY` in POSIX.\n   */\n  directory?: boolean,\n  /**\n   * Fail if file already exists, similar to `O_EXCL` in POSIX.\n   */\n  exclusive?: boolean,\n  /**\n   * Truncate file to size 0, similar to `O_TRUNC` in POSIX.\n   */\n  truncate?: boolean,\n}\n/**\n * Permissions mode used by `open-at`, `change-file-permissions-at`, and\n * similar.\n */\nexport interface Modes {\n  /**\n   * True if the resource is considered readable by the containing\n   * filesystem.\n   */\n  readable?: boolean,\n  /**\n   * True if the resource is considered writable by the containing\n   * filesystem.\n   */\n  writable?: boolean,\n  /**\n   * True if the resource is considered executable by the containing\n   * filesystem. This does not apply to directories.\n   */\n  executable?: boolean,\n}\n/**\n * Number of hard links to an inode.\n */\nexport type LinkCount = bigint;\n/**\n * Filesystem object serial number that is unique within its file system.\n */\nexport type Inode = bigint;\n/**\n * File size or length of a region within a file.\n */\nexport type Filesize = bigint;\n/**\n * Error codes returned by functions, similar to `errno` in POSIX.\n * Not all of these error codes are returned by the functions provided by this\n * API; some are used in higher-level library layers, and others are provided\n * merely for alignment with POSIX.\n * \n * # Variants\n * \n * ## `\"access\"`\n * \n * Permission denied, similar to `EACCES` in POSIX.\n * \n * ## `\"would-block\"`\n * \n * Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in POSIX.\n * \n * ## `\"already\"`\n * \n * Connection already in progress, similar to `EALREADY` in POSIX.\n * \n * ## `\"bad-descriptor\"`\n * \n * Bad descriptor, similar to `EBADF` in POSIX.\n * \n * ## `\"busy\"`\n * \n * Device or resource busy, similar to `EBUSY` in POSIX.\n * \n * ## `\"deadlock\"`\n * \n * Resource deadlock would occur, similar to `EDEADLK` in POSIX.\n * \n * ## `\"quota\"`\n * \n * Storage quota exceeded, similar to `EDQUOT` in POSIX.\n * \n * ## `\"exist\"`\n * \n * File exists, similar to `EEXIST` in POSIX.\n * \n * ## `\"file-too-large\"`\n * \n * File too large, similar to `EFBIG` in POSIX.\n * \n * ## `\"illegal-byte-sequence\"`\n * \n * Illegal byte sequence, similar to `EILSEQ` in POSIX.\n * \n * ## `\"in-progress\"`\n * \n * Operation in progress, similar to `EINPROGRESS` in POSIX.\n * \n * ## `\"interrupted\"`\n * \n * Interrupted function, similar to `EINTR` in POSIX.\n * \n * ## `\"invalid\"`\n * \n * Invalid argument, similar to `EINVAL` in POSIX.\n * \n * ## `\"io\"`\n * \n * I/O error, similar to `EIO` in POSIX.\n * \n * ## `\"is-directory\"`\n * \n * Is a directory, similar to `EISDIR` in POSIX.\n * \n * ## `\"loop\"`\n * \n * Too many levels of symbolic links, similar to `ELOOP` in POSIX.\n * \n * ## `\"too-many-links\"`\n * \n * Too many links, similar to `EMLINK` in POSIX.\n * \n * ## `\"message-size\"`\n * \n * Message too large, similar to `EMSGSIZE` in POSIX.\n * \n * ## `\"name-too-long\"`\n * \n * Filename too long, similar to `ENAMETOOLONG` in POSIX.\n * \n * ## `\"no-device\"`\n * \n * No such device, similar to `ENODEV` in POSIX.\n * \n * ## `\"no-entry\"`\n * \n * No such file or directory, similar to `ENOENT` in POSIX.\n * \n * ## `\"no-lock\"`\n * \n * No locks available, similar to `ENOLCK` in POSIX.\n * \n * ## `\"insufficient-memory\"`\n * \n * Not enough space, similar to `ENOMEM` in POSIX.\n * \n * ## `\"insufficient-space\"`\n * \n * No space left on device, similar to `ENOSPC` in POSIX.\n * \n * ## `\"not-directory\"`\n * \n * Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.\n * \n * ## `\"not-empty\"`\n * \n * Directory not empty, similar to `ENOTEMPTY` in POSIX.\n * \n * ## `\"not-recoverable\"`\n * \n * State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.\n * \n * ## `\"unsupported\"`\n * \n * Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.\n * \n * ## `\"no-tty\"`\n * \n * Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.\n * \n * ## `\"no-such-device\"`\n * \n * No such device or address, similar to `ENXIO` in POSIX.\n * \n * ## `\"overflow\"`\n * \n * Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.\n * \n * ## `\"not-permitted\"`\n * \n * Operation not permitted, similar to `EPERM` in POSIX.\n * \n * ## `\"pipe\"`\n * \n * Broken pipe, similar to `EPIPE` in POSIX.\n * \n * ## `\"read-only\"`\n * \n * Read-only file system, similar to `EROFS` in POSIX.\n * \n * ## `\"invalid-seek\"`\n * \n * Invalid seek, similar to `ESPIPE` in POSIX.\n * \n * ## `\"text-file-busy\"`\n * \n * Text file busy, similar to `ETXTBSY` in POSIX.\n * \n * ## `\"cross-device\"`\n * \n * Cross-device link, similar to `EXDEV` in POSIX.\n */\nexport type ErrorCode = 'access' | 'would-block' | 'already' | 'bad-descriptor' | 'busy' | 'deadlock' | 'quota' | 'exist' | 'file-too-large' | 'illegal-byte-sequence' | 'in-progress' | 'interrupted' | 'invalid' | 'io' | 'is-directory' | 'loop' | 'too-many-links' | 'message-size' | 'name-too-long' | 'no-device' | 'no-entry' | 'no-lock' | 'insufficient-memory' | 'insufficient-space' | 'not-directory' | 'not-empty' | 'not-recoverable' | 'unsupported' | 'no-tty' | 'no-such-device' | 'overflow' | 'not-permitted' | 'pipe' | 'read-only' | 'invalid-seek' | 'text-file-busy' | 'cross-device';\n/**\n * A stream of directory entries.\n * \n * This [represents a stream of `dir-entry`](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Streams).\n */\nexport type DirectoryEntryStream = number;\n/**\n * Identifier for a device containing a file system. Can be used in\n * combination with `inode` to uniquely identify a file or directory in\n * the filesystem.\n */\nexport type Device = bigint;\n/**\n * The type of a filesystem object referenced by a descriptor.\n * \n * Note: This was called `filetype` in earlier versions of WASI.\n * \n * # Variants\n * \n * ## `\"unknown\"`\n * \n * The type of the descriptor or file is unknown or is different from\n * any of the other types specified.\n * \n * ## `\"block-device\"`\n * \n * The descriptor refers to a block device inode.\n * \n * ## `\"character-device\"`\n * \n * The descriptor refers to a character device inode.\n * \n * ## `\"directory\"`\n * \n * The descriptor refers to a directory inode.\n * \n * ## `\"fifo\"`\n * \n * The descriptor refers to a named pipe.\n * \n * ## `\"symbolic-link\"`\n * \n * The file refers to a symbolic link inode.\n * \n * ## `\"regular-file\"`\n * \n * The descriptor refers to a regular file inode.\n * \n * ## `\"socket\"`\n * \n * The descriptor refers to a socket.\n */\nexport type DescriptorType = 'unknown' | 'block-device' | 'character-device' | 'directory' | 'fifo' | 'symbolic-link' | 'regular-file' | 'socket';\n/**\n * A directory entry.\n */\nexport interface DirectoryEntry {\n  /**\n   * The serial number of the object referred to by this directory entry.\n   * May be none if the inode value is not known.\n   * \n   * When this is none, libc implementations might do an extra `stat-at`\n   * call to retrieve the inode number to fill their `d_ino` fields, so\n   * implementations which can set this to a non-none value should do so.\n   */\n  inode?: Inode,\n  /**\n   * The type of the file referred to by this directory entry.\n   */\n  type: DescriptorType,\n  /**\n   * The name of the object.\n   */\n  name: string,\n}\n/**\n * Descriptor flags.\n * \n * Note: This was called `fdflags` in earlier versions of WASI.\n */\nexport interface DescriptorFlags {\n  /**\n   * Read mode: Data can be read.\n   */\n  read?: boolean,\n  /**\n   * Write mode: Data can be written to.\n   */\n  write?: boolean,\n  /**\n   * Request that writes be performed according to synchronized I/O file\n   * integrity completion. The data stored in the file and the file's\n   * metadata are synchronized. This is similar to `O_SYNC` in POSIX.\n   * \n   * The precise semantics of this operation have not yet been defined for\n   * WASI. At this time, it should be interpreted as a request, and not a\n   * requirement.\n   */\n  fileIntegritySync?: boolean,\n  /**\n   * Request that writes be performed according to synchronized I/O data\n   * integrity completion. Only the data stored in the file is\n   * synchronized. This is similar to `O_DSYNC` in POSIX.\n   * \n   * The precise semantics of this operation have not yet been defined for\n   * WASI. At this time, it should be interpreted as a request, and not a\n   * requirement.\n   */\n  dataIntegritySync?: boolean,\n  /**\n   * Requests that reads be performed at the same level of integrety\n   * requested for writes. This is similar to `O_RSYNC` in POSIX.\n   * \n   * The precise semantics of this operation have not yet been defined for\n   * WASI. At this time, it should be interpreted as a request, and not a\n   * requirement.\n   */\n  requestedWriteSync?: boolean,\n  /**\n   * Mutating directories mode: Directory contents may be mutated.\n   * \n   * When this flag is unset on a descriptor, operations using the\n   * descriptor which would create, rename, delete, modify the data or\n   * metadata of filesystem objects, or obtain another handle which\n   * would permit any of those, shall fail with `error-code::read-only` if\n   * they would otherwise succeed.\n   * \n   * This may only be set on directories.\n   */\n  mutateDirectory?: boolean,\n}\n/**\n * A descriptor is a reference to a filesystem object, which may be a file,\n * directory, named pipe, special file, or other object on which filesystem\n * calls may be made.\n * \n * This [represents a resource](https://github.com/WebAssembly/WASI/blob/main/docs/WitInWasi.md#Resources).\n */\nexport type Descriptor = number;\n/**\n * When setting a timestamp, this gives the value to set it to.\n */\nexport type NewTimestamp = NewTimestampNoChange | NewTimestampNow | NewTimestampTimestamp;\n/**\n * Leave the timestamp set to its previous value.\n */\nexport interface NewTimestampNoChange {\n  tag: 'no-change',\n}\n/**\n * Set the timestamp to the current time of the system clock associated\n * with the filesystem.\n */\nexport interface NewTimestampNow {\n  tag: 'now',\n}\n/**\n * Set the timestamp to the given value.\n */\nexport interface NewTimestampTimestamp {\n  tag: 'timestamp',\n  val: Datetime,\n}\n/**\n * File attributes.\n * \n * Note: This was called `filestat` in earlier versions of WASI.\n */\nexport interface DescriptorStat {\n  /**\n   * Device ID of device containing the file.\n   */\n  device: Device,\n  /**\n   * File serial number.\n   */\n  inode: Inode,\n  /**\n   * File type.\n   */\n  type: DescriptorType,\n  /**\n   * Number of hard links to the file.\n   */\n  linkCount: LinkCount,\n  /**\n   * For regular files, the file size in bytes. For symbolic links, the\n   * length in bytes of the pathname contained in the symbolic link.\n   */\n  size: Filesize,\n  /**\n   * Last data access timestamp.\n   */\n  dataAccessTimestamp: Datetime,\n  /**\n   * Last data modification timestamp.\n   */\n  dataModificationTimestamp: Datetime,\n  /**\n   * Last file status change timestamp.\n   */\n  statusChangeTimestamp: Datetime,\n}\n/**\n * File or memory access pattern advisory information.\n * \n * # Variants\n * \n * ## `\"normal\"`\n * \n * The application has no advice to give on its behavior with respect\n * to the specified data.\n * \n * ## `\"sequential\"`\n * \n * The application expects to access the specified data sequentially\n * from lower offsets to higher offsets.\n * \n * ## `\"random\"`\n * \n * The application expects to access the specified data in a random\n * order.\n * \n * ## `\"will-need\"`\n * \n * The application expects to access the specified data in the near\n * future.\n * \n * ## `\"dont-need\"`\n * \n * The application expects that it will not access the specified data\n * in the near future.\n * \n * ## `\"no-reuse\"`\n * \n * The application expects to access the specified data once and then\n * not reuse it thereafter.\n */\nexport type Advice = 'normal' | 'sequential' | 'random' | 'will-need' | 'dont-need' | 'no-reuse';\n/**\n * Access type used by `access-at`.\n */\nexport type AccessType = AccessTypeAccess | AccessTypeExists;\n/**\n * Test for readability, writeability, or executability.\n */\nexport interface AccessTypeAccess {\n  tag: 'access',\n  val: Modes,\n}\n/**\n * Test whether the path exists.\n */\nexport interface AccessTypeExists {\n  tag: 'exists',\n}\n"]}