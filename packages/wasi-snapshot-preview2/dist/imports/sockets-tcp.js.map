{"version":3,"file":"sockets-tcp.js","sourceRoot":"","sources":["../../src/imports/sockets-tcp.ts"],"names":[],"mappings":"","sourcesContent":["export interface SocketsTcp {\n  /**\n   * Bind the socket to a specific network on the provided IP address and port.\n   * \n   * If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which\n   * network interface(s) to bind to.\n   * If the TCP/UDP port is zero, the socket will be bound to a random free port.\n   * \n   * When a socket is not explicitly bound, the first invocation to a listen or connect operation will\n   * implicitly bind the socket.\n   * \n   * Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.\n   * \n   * # Typical `start` errors\n   * - `address-family-mismatch`:   The `local-address` has the wrong address family. (EINVAL)\n   * - `already-bound`:             The socket is already bound. (EINVAL)\n   * - `concurrency-conflict`:      Another `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   * \n   * # Typical `finish` errors\n   * - `ephemeral-ports-exhausted`: No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)\n   * - `address-in-use`:            Address is already in use. (EADDRINUSE)\n   * - `address-not-bindable`:      `local-address` is not an address that the `network` can bind to. (EADDRNOTAVAIL)\n   * - `not-in-progress`:           A `bind` operation is not in progress.\n   * - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>\n   * - <https://man7.org/linux/man-pages/man2/bind.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>\n   * - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>\n   */\n   startBind(this0: TcpSocket, network: Network, localAddress: IpSocketAddress): void;\n   finishBind(this0: TcpSocket): void;\n  /**\n   * Connect to a remote endpoint.\n   * \n   * On success:\n   * - the socket is transitioned into the Connection state\n   * - a pair of streams is returned that can be used to read & write to the connection\n   * \n   * # Typical `start` errors\n   * - `address-family-mismatch`:   The `remote-address` has the wrong address family. (EAFNOSUPPORT)\n   * - `invalid-remote-address`:    The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EADDRNOTAVAIL on Windows)\n   * - `invalid-remote-address`:    The port in `remote-address` is set to 0. (EADDRNOTAVAIL on Windows)\n   * - `already-attached`:          The socket is already attached to a different network. The `network` passed to `connect` must be identical to the one passed to `bind`.\n   * - `already-connected`:         The socket is already in the Connection state. (EISCONN)\n   * - `already-listening`:         The socket is already in the Listener state. (EOPNOTSUPP, EINVAL on Windows)\n   * - `concurrency-conflict`:      Another `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   * \n   * # Typical `finish` errors\n   * - `timeout`:                   Connection timed out. (ETIMEDOUT)\n   * - `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)\n   * - `connection-reset`:          The connection was reset. (ECONNRESET)\n   * - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN)\n   * - `ephemeral-ports-exhausted`: Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)\n   * - `not-in-progress`:           A `connect` operation is not in progress.\n   * - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>\n   * - <https://man7.org/linux/man-pages/man2/connect.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>\n   * - <https://man.freebsd.org/cgi/man.cgi?connect>\n   */\n   startConnect(this0: TcpSocket, network: Network, remoteAddress: IpSocketAddress): void;\n   finishConnect(this0: TcpSocket): [InputStream, OutputStream];\n  /**\n   * Start listening for new connections.\n   * \n   * Transitions the socket into the Listener state.\n   * \n   * Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.\n   * \n   * # Typical `start` errors\n   * - `already-attached`:          The socket is already attached to a different network. The `network` passed to `listen` must be identical to the one passed to `bind`.\n   * - `already-connected`:         The socket is already in the Connection state. (EISCONN, EINVAL on BSD)\n   * - `already-listening`:         The socket is already in the Listener state.\n   * - `concurrency-conflict`:      Another `bind`, `connect` or `listen` operation is already in progress. (EINVAL on BSD)\n   * \n   * # Typical `finish` errors\n   * - `ephemeral-ports-exhausted`: Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE)\n   * - `not-in-progress`:           A `listen` operation is not in progress.\n   * - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>\n   * - <https://man7.org/linux/man-pages/man2/listen.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>\n   * - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>\n   */\n   startListen(this0: TcpSocket, network: Network): void;\n   finishListen(this0: TcpSocket): void;\n  /**\n   * Accept a new client socket.\n   * \n   * The returned socket is bound and in the Connection state.\n   * \n   * On success, this function returns the newly accepted client socket along with\n   * a pair of streams that can be used to read & write to the connection.\n   * \n   * # Typical errors\n   * - `not-listening`: Socket is not in the Listener state. (EINVAL)\n   * - `would-block`:   No pending connections at the moment. (EWOULDBLOCK, EAGAIN)\n   * \n   * Host implementations must skip over transient errors returned by the native accept syscall.\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>\n   * - <https://man7.org/linux/man-pages/man2/accept.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>\n   * - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>\n   */\n   accept(this0: TcpSocket): [TcpSocket, InputStream, OutputStream];\n  /**\n   * Get the bound local address.\n   * \n   * # Typical errors\n   * - `not-bound`: The socket is not bound to any local address.\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>\n   * - <https://man7.org/linux/man-pages/man2/getsockname.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>\n   * - <https://man.freebsd.org/cgi/man.cgi?getsockname>\n   */\n   localAddress(this0: TcpSocket): IpSocketAddress;\n  /**\n   * Get the bound remote address.\n   * \n   * # Typical errors\n   * - `not-connected`: The socket is not connected to a remote address. (ENOTCONN)\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>\n   * - <https://man7.org/linux/man-pages/man2/getpeername.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>\n   * - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>\n   */\n   remoteAddress(this0: TcpSocket): IpSocketAddress;\n  /**\n   * Whether this is a IPv4 or IPv6 socket.\n   * \n   * Equivalent to the SO_DOMAIN socket option.\n   */\n   addressFamily(this0: TcpSocket): IpAddressFamily;\n  /**\n   * Whether IPv4 compatibility (dual-stack) mode is disabled or not.\n   * \n   * Equivalent to the IPV6_V6ONLY socket option.\n   * \n   * # Typical errors\n   * - `ipv6-only-operation`:  (get/set) `this` socket is an IPv4 socket.\n   * - `already-bound`:        (set) The socket is already bound.\n   * - `not-supported`:        (set) Host does not support dual-stack sockets. (Implementations are not required to.)\n   * - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   */\n   ipv6Only(this0: TcpSocket): boolean;\n   setIpv6Only(this0: TcpSocket, value: boolean): void;\n  /**\n   * Hints the desired listen queue size. Implementations are free to ignore this.\n   * \n   * # Typical errors\n   * - `already-connected`:    (set) The socket is already in the Connection state.\n   * - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   */\n   setListenBacklogSize(this0: TcpSocket, value: bigint): void;\n  /**\n   * Equivalent to the SO_KEEPALIVE socket option.\n   * \n   * # Typical errors\n   * - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   */\n   keepAlive(this0: TcpSocket): boolean;\n   setKeepAlive(this0: TcpSocket, value: boolean): void;\n  /**\n   * Equivalent to the TCP_NODELAY socket option.\n   * \n   * # Typical errors\n   * - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   */\n   noDelay(this0: TcpSocket): boolean;\n   setNoDelay(this0: TcpSocket, value: boolean): void;\n  /**\n   * Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.\n   * \n   * # Typical errors\n   * - `already-connected`:    (set) The socket is already in the Connection state.\n   * - `already-listening`:    (set) The socket is already in the Listener state.\n   * - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   */\n   unicastHopLimit(this0: TcpSocket): number;\n   setUnicastHopLimit(this0: TcpSocket, value: number): void;\n  /**\n   * The kernel buffer space reserved for sends/receives on this socket.\n   * \n   * Note #1: an implementation may choose to cap or round the buffer size when setting the value.\n   * In other words, after setting a value, reading the same setting back may return a different value.\n   * \n   * Note #2: there is not necessarily a direct relationship between the kernel buffer size and the bytes of\n   * actual data to be sent/received by the application, because the kernel might also use the buffer space\n   * for internal metadata structures.\n   * \n   * Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.\n   * \n   * # Typical errors\n   * - `already-connected`:    (set) The socket is already in the Connection state.\n   * - `already-listening`:    (set) The socket is already in the Listener state.\n   * - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   */\n   receiveBufferSize(this0: TcpSocket): bigint;\n   setReceiveBufferSize(this0: TcpSocket, value: bigint): void;\n   sendBufferSize(this0: TcpSocket): bigint;\n   setSendBufferSize(this0: TcpSocket, value: bigint): void;\n  /**\n   * Create a `pollable` which will resolve once the socket is ready for I/O.\n   * \n   * Note: this function is here for WASI Preview2 only.\n   * It's planned to be removed when `future` is natively supported in Preview3.\n   */\n   subscribe(this0: TcpSocket): Pollable;\n  /**\n   * Initiate a graceful shutdown.\n   * \n   * - receive: the socket is not expecting to receive any more data from the peer. All subsequent read\n   * operations on the `input-stream` associated with this socket will return an End Of Stream indication.\n   * Any data still in the receive queue at time of calling `shutdown` will be discarded.\n   * - send: the socket is not expecting to send any more data to the peer. All subsequent write\n   * operations on the `output-stream` associated with this socket will return an error.\n   * - both: same effect as receive & send combined.\n   * \n   * The shutdown function does not close (drop) the socket.\n   * \n   * # Typical errors\n   * - `not-connected`: The socket is not in the Connection state. (ENOTCONN)\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html>\n   * - <https://man7.org/linux/man-pages/man2/shutdown.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-shutdown>\n   * - <https://man.freebsd.org/cgi/man.cgi?query=shutdown&sektion=2>\n   */\n   shutdown(this0: TcpSocket, shutdownType: ShutdownType): void;\n  /**\n   * Dispose of the specified `tcp-socket`, after which it may no longer be used.\n   * \n   * Similar to the POSIX `close` function.\n   * \n   * Note: this function is scheduled to be removed when Resources are natively supported in Wit.\n   */\n   dropTcpSocket(this0: TcpSocket): void;\n}\nexport interface SocketsTcpAsync {\n  /**\n   * Bind the socket to a specific network on the provided IP address and port.\n   * \n   * If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which\n   * network interface(s) to bind to.\n   * If the TCP/UDP port is zero, the socket will be bound to a random free port.\n   * \n   * When a socket is not explicitly bound, the first invocation to a listen or connect operation will\n   * implicitly bind the socket.\n   * \n   * Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.\n   * \n   * # Typical `start` errors\n   * - `address-family-mismatch`:   The `local-address` has the wrong address family. (EINVAL)\n   * - `already-bound`:             The socket is already bound. (EINVAL)\n   * - `concurrency-conflict`:      Another `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   * \n   * # Typical `finish` errors\n   * - `ephemeral-ports-exhausted`: No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)\n   * - `address-in-use`:            Address is already in use. (EADDRINUSE)\n   * - `address-not-bindable`:      `local-address` is not an address that the `network` can bind to. (EADDRNOTAVAIL)\n   * - `not-in-progress`:           A `bind` operation is not in progress.\n   * - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>\n   * - <https://man7.org/linux/man-pages/man2/bind.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>\n   * - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>\n   */\n   startBind(this0: TcpSocket, network: Network, localAddress: IpSocketAddress): Promise<void>;\n   finishBind(this0: TcpSocket): Promise<void>;\n  /**\n   * Connect to a remote endpoint.\n   * \n   * On success:\n   * - the socket is transitioned into the Connection state\n   * - a pair of streams is returned that can be used to read & write to the connection\n   * \n   * # Typical `start` errors\n   * - `address-family-mismatch`:   The `remote-address` has the wrong address family. (EAFNOSUPPORT)\n   * - `invalid-remote-address`:    The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EADDRNOTAVAIL on Windows)\n   * - `invalid-remote-address`:    The port in `remote-address` is set to 0. (EADDRNOTAVAIL on Windows)\n   * - `already-attached`:          The socket is already attached to a different network. The `network` passed to `connect` must be identical to the one passed to `bind`.\n   * - `already-connected`:         The socket is already in the Connection state. (EISCONN)\n   * - `already-listening`:         The socket is already in the Listener state. (EOPNOTSUPP, EINVAL on Windows)\n   * - `concurrency-conflict`:      Another `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   * \n   * # Typical `finish` errors\n   * - `timeout`:                   Connection timed out. (ETIMEDOUT)\n   * - `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)\n   * - `connection-reset`:          The connection was reset. (ECONNRESET)\n   * - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN)\n   * - `ephemeral-ports-exhausted`: Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)\n   * - `not-in-progress`:           A `connect` operation is not in progress.\n   * - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>\n   * - <https://man7.org/linux/man-pages/man2/connect.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>\n   * - <https://man.freebsd.org/cgi/man.cgi?connect>\n   */\n   startConnect(this0: TcpSocket, network: Network, remoteAddress: IpSocketAddress): Promise<void>;\n   finishConnect(this0: TcpSocket): Promise<[InputStream, OutputStream]>;\n  /**\n   * Start listening for new connections.\n   * \n   * Transitions the socket into the Listener state.\n   * \n   * Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.\n   * \n   * # Typical `start` errors\n   * - `already-attached`:          The socket is already attached to a different network. The `network` passed to `listen` must be identical to the one passed to `bind`.\n   * - `already-connected`:         The socket is already in the Connection state. (EISCONN, EINVAL on BSD)\n   * - `already-listening`:         The socket is already in the Listener state.\n   * - `concurrency-conflict`:      Another `bind`, `connect` or `listen` operation is already in progress. (EINVAL on BSD)\n   * \n   * # Typical `finish` errors\n   * - `ephemeral-ports-exhausted`: Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE)\n   * - `not-in-progress`:           A `listen` operation is not in progress.\n   * - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>\n   * - <https://man7.org/linux/man-pages/man2/listen.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>\n   * - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>\n   */\n   startListen(this0: TcpSocket, network: Network): Promise<void>;\n   finishListen(this0: TcpSocket): Promise<void>;\n  /**\n   * Accept a new client socket.\n   * \n   * The returned socket is bound and in the Connection state.\n   * \n   * On success, this function returns the newly accepted client socket along with\n   * a pair of streams that can be used to read & write to the connection.\n   * \n   * # Typical errors\n   * - `not-listening`: Socket is not in the Listener state. (EINVAL)\n   * - `would-block`:   No pending connections at the moment. (EWOULDBLOCK, EAGAIN)\n   * \n   * Host implementations must skip over transient errors returned by the native accept syscall.\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>\n   * - <https://man7.org/linux/man-pages/man2/accept.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>\n   * - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>\n   */\n   accept(this0: TcpSocket): Promise<[TcpSocket, InputStream, OutputStream]>;\n  /**\n   * Get the bound local address.\n   * \n   * # Typical errors\n   * - `not-bound`: The socket is not bound to any local address.\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>\n   * - <https://man7.org/linux/man-pages/man2/getsockname.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>\n   * - <https://man.freebsd.org/cgi/man.cgi?getsockname>\n   */\n   localAddress(this0: TcpSocket): Promise<IpSocketAddress>;\n  /**\n   * Get the bound remote address.\n   * \n   * # Typical errors\n   * - `not-connected`: The socket is not connected to a remote address. (ENOTCONN)\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>\n   * - <https://man7.org/linux/man-pages/man2/getpeername.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>\n   * - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>\n   */\n   remoteAddress(this0: TcpSocket): Promise<IpSocketAddress>;\n  /**\n   * Whether this is a IPv4 or IPv6 socket.\n   * \n   * Equivalent to the SO_DOMAIN socket option.\n   */\n   addressFamily(this0: TcpSocket): Promise<IpAddressFamily>;\n  /**\n   * Whether IPv4 compatibility (dual-stack) mode is disabled or not.\n   * \n   * Equivalent to the IPV6_V6ONLY socket option.\n   * \n   * # Typical errors\n   * - `ipv6-only-operation`:  (get/set) `this` socket is an IPv4 socket.\n   * - `already-bound`:        (set) The socket is already bound.\n   * - `not-supported`:        (set) Host does not support dual-stack sockets. (Implementations are not required to.)\n   * - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   */\n   ipv6Only(this0: TcpSocket): Promise<boolean>;\n   setIpv6Only(this0: TcpSocket, value: boolean): Promise<void>;\n  /**\n   * Hints the desired listen queue size. Implementations are free to ignore this.\n   * \n   * # Typical errors\n   * - `already-connected`:    (set) The socket is already in the Connection state.\n   * - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   */\n   setListenBacklogSize(this0: TcpSocket, value: bigint): Promise<void>;\n  /**\n   * Equivalent to the SO_KEEPALIVE socket option.\n   * \n   * # Typical errors\n   * - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   */\n   keepAlive(this0: TcpSocket): Promise<boolean>;\n   setKeepAlive(this0: TcpSocket, value: boolean): Promise<void>;\n  /**\n   * Equivalent to the TCP_NODELAY socket option.\n   * \n   * # Typical errors\n   * - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   */\n   noDelay(this0: TcpSocket): Promise<boolean>;\n   setNoDelay(this0: TcpSocket, value: boolean): Promise<void>;\n  /**\n   * Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.\n   * \n   * # Typical errors\n   * - `already-connected`:    (set) The socket is already in the Connection state.\n   * - `already-listening`:    (set) The socket is already in the Listener state.\n   * - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   */\n   unicastHopLimit(this0: TcpSocket): Promise<number>;\n   setUnicastHopLimit(this0: TcpSocket, value: number): Promise<void>;\n  /**\n   * The kernel buffer space reserved for sends/receives on this socket.\n   * \n   * Note #1: an implementation may choose to cap or round the buffer size when setting the value.\n   * In other words, after setting a value, reading the same setting back may return a different value.\n   * \n   * Note #2: there is not necessarily a direct relationship between the kernel buffer size and the bytes of\n   * actual data to be sent/received by the application, because the kernel might also use the buffer space\n   * for internal metadata structures.\n   * \n   * Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.\n   * \n   * # Typical errors\n   * - `already-connected`:    (set) The socket is already in the Connection state.\n   * - `already-listening`:    (set) The socket is already in the Listener state.\n   * - `concurrency-conflict`: (set) A `bind`, `connect` or `listen` operation is already in progress. (EALREADY)\n   */\n   receiveBufferSize(this0: TcpSocket): Promise<bigint>;\n   setReceiveBufferSize(this0: TcpSocket, value: bigint): Promise<void>;\n   sendBufferSize(this0: TcpSocket): Promise<bigint>;\n   setSendBufferSize(this0: TcpSocket, value: bigint): Promise<void>;\n  /**\n   * Create a `pollable` which will resolve once the socket is ready for I/O.\n   * \n   * Note: this function is here for WASI Preview2 only.\n   * It's planned to be removed when `future` is natively supported in Preview3.\n   */\n   subscribe(this0: TcpSocket): Promise<Pollable>;\n  /**\n   * Initiate a graceful shutdown.\n   * \n   * - receive: the socket is not expecting to receive any more data from the peer. All subsequent read\n   * operations on the `input-stream` associated with this socket will return an End Of Stream indication.\n   * Any data still in the receive queue at time of calling `shutdown` will be discarded.\n   * - send: the socket is not expecting to send any more data to the peer. All subsequent write\n   * operations on the `output-stream` associated with this socket will return an error.\n   * - both: same effect as receive & send combined.\n   * \n   * The shutdown function does not close (drop) the socket.\n   * \n   * # Typical errors\n   * - `not-connected`: The socket is not in the Connection state. (ENOTCONN)\n   * \n   * # References\n   * - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html>\n   * - <https://man7.org/linux/man-pages/man2/shutdown.2.html>\n   * - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-shutdown>\n   * - <https://man.freebsd.org/cgi/man.cgi?query=shutdown&sektion=2>\n   */\n   shutdown(this0: TcpSocket, shutdownType: ShutdownType): Promise<void>;\n  /**\n   * Dispose of the specified `tcp-socket`, after which it may no longer be used.\n   * \n   * Similar to the POSIX `close` function.\n   * \n   * Note: this function is scheduled to be removed when Resources are natively supported in Wit.\n   */\n   dropTcpSocket(this0: TcpSocket): Promise<void>;\n}\nimport type { InputStream } from '../imports/io-streams';\nexport { InputStream };\nimport type { OutputStream } from '../imports/io-streams';\nexport { OutputStream };\nimport type { Pollable } from '../imports/poll-poll';\nexport { Pollable };\nimport type { Network } from '../imports/sockets-network';\nexport { Network };\nimport type { ErrorCode } from '../imports/sockets-network';\nexport { ErrorCode };\nimport type { IpSocketAddress } from '../imports/sockets-network';\nexport { IpSocketAddress };\nimport type { IpAddressFamily } from '../imports/sockets-network';\nexport { IpAddressFamily };\n/**\n * A TCP socket handle.\n */\nexport type TcpSocket = number;\n/**\n * # Variants\n * \n * ## `\"receive\"`\n * \n * Similar to `SHUT_RD` in POSIX.\n * \n * ## `\"send\"`\n * \n * Similar to `SHUT_WR` in POSIX.\n * \n * ## `\"both\"`\n * \n * Similar to `SHUT_RDWR` in POSIX.\n */\nexport type ShutdownType = 'receive' | 'send' | 'both';\n"]}