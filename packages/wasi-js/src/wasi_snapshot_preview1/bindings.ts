/*
 * This file was automatically generated by witx-codegen - Do not edit manually.
 */

// Pointer to target
export type ptr<T> = number & { _pointerTarget: T };
// Mutable pointer to target
export type mutptr<T> = ptr<T>;

// Type Definition for complex and simple types
export interface TypeDef<T> {
    size: number;
    align: number;

    get(buf: ArrayBuffer, ptr: ptr<T>): T;
    set(buf: ArrayBuffer, ptr: ptr<T>, value: T): void;
}
// Get target JS type of TypeDef
export type TargetType<D> = D extends TypeDef<infer T> ? T : never;

const getDataView = (() => {
    const cache = new WeakMap<ArrayBuffer, DataView>();

    return (buf: ArrayBuffer) => {
        let dataView = cache.get(buf);
        if (!dataView) {
            dataView = new DataView(buf);
            cache.set(buf, dataView);
        }
        return dataView;
    };
})();

// Function to get TypeDef for primitive JS types
function std<T = number>(name: string, size: number): TypeDef<T> {
    const get = (DataView.prototype as any)[`get${name}`];
    const set = (DataView.prototype as any)[`set${name}`];

    return {
        size,
        align: size,
        get(buf, ptr) {
            return get.call(getDataView(buf), ptr, true);
        },
        set(buf, ptr, value) {
            return set.call(getDataView(buf), ptr, value, true);
        },
    };
}

// Function for UTF-8 strings
export const string = (() => {
    const textEncoder = new TextEncoder();
    const textDecoder = new TextDecoder();

    return {
        get(buf: ArrayBuffer, ptr: ptr<string>, len: number): string {
            return textDecoder.decode(new Uint8Array(buf, ptr, len));
        },
        set(buf: ArrayBuffer, ptr: ptr<string>, value: string, len?: number | undefined) {
            if (len) {
                const { read } = textEncoder.encodeInto(value, new Uint8Array(buf, ptr, len));
                if (read! < value.length) {
                    throw new Error(`Insufficient space.`);
                }
            } else {
                // we don't know the string length beforehand
                const src = textEncoder.encode(value);
                len = src.byteLength;
                const dst = new Uint8Array(buf, ptr, len);
                dst.set(src);
            }
        },
    };
})();

function alignTo(ptr: number, align: number): number {
    const mismatch = ptr % align;
    if (mismatch) {
        ptr += align - mismatch;
    }
    return ptr;
}

// To construct TypeDef for structs
export function struct<T extends Record<string, TypeDef<any>>>(
    desc: T
): TypeDef<{ [K in keyof T]: T[K] extends TypeDef<infer F> ? F : never }> {
    class Ctor {
        constructor(protected _buf: ArrayBuffer, protected _ptr: number) {}
    }
    let offset = 0;
    let structAlign = 0;
    for (const name in desc) {
        const type = desc[name];
        const fieldAlign = type.align;
        structAlign = Math.max(structAlign, fieldAlign);
        offset = alignTo(offset, fieldAlign);
        const fieldOffset = offset;
        Object.defineProperty(Ctor.prototype, name, {
            get(this: Ctor) {
                return type.get(this._buf, (this._ptr + fieldOffset) as ptr<any>);
            },
            set(this: Ctor, value) {
                type.set(this._buf, (this._ptr + fieldOffset) as ptr<any>, value);
            },
        });
        offset += type.size;
    }
    offset = alignTo(offset, structAlign);
    return {
        size: offset,
        align: structAlign,
        get(buf, ptr) {
            return new Ctor(buf, ptr) as any;
        },
        set(buf, ptr, value) {
            Object.assign(new Ctor(buf, ptr), value);
        },
    };
}

// To construct TypeDef for taggedUnion
export function taggedUnion<E extends number, T extends Record<E, TypeDef<any>>>({
    tag: tagDesc,
    data: dataDesc,
}: {
    tag: TypeDef<E>;
    data: T;
}): TypeDef<
    {
        [K in E]: { tag: K; data: T[K] extends TypeDef<infer F> ? F : never };
    }[E]
> {
    let unionSize = 0;
    let unionAlign = 0;
    for (const key in dataDesc) {
        const { size, align } = dataDesc[key];
        unionSize = Math.max(unionSize, size);
        unionAlign = Math.max(unionAlign, align);
    }
    unionSize = alignTo(unionSize, unionAlign);
    const unionOffset = alignTo(tagDesc.size, unionAlign);
    const totalAlign = Math.max(tagDesc.align, unionAlign);
    const totalSize = alignTo(unionOffset + unionSize, totalAlign);
    return {
        size: totalSize,
        align: totalAlign,
        get(buf, ptr) {
            const tag = tagDesc.get(buf, ptr as ptr<any>);
            return {
                tag,
                data: dataDesc[tag].get(buf, (ptr + unionOffset) as ptr<any>),
            };
        },
        set(buf, ptr, value) {
            tagDesc.set(buf, ptr as ptr<any>, value.tag);
            dataDesc[value.tag].set(buf, (ptr + unionOffset) as ptr<any>, value.data);
        },
    };
}

// To construct TypeDef for enum
export function enumer<E extends number>(base: TypeDef<number>): TypeDef<E> {
    // All the properties are same as for the underlying number, this wrapper is only useful at typechecking level.
    return base as TypeDef<E>;
}

export const i8 = std("Int8", 1);
export type i8 = number;
export const u8 = std("Uint8", 1);
export type u8 = number;
export const i16 = std("Int16", 2);
export type i16 = number;
export const u16 = std("Uint16", 2);
export type u16 = number;
export const i32 = std("Int32", 4);
export type i32 = number;
export const u32 = std("Uint32", 4);
export type u32 = number;
export const usize = std("Uint32", 4);
export type usize = number;
export const i64 = std<bigint>("bigint64", 8);
export type i64 = bigint;
export const u64 = std<bigint>("BigUint64", 8);
export type u64 = bigint;

export const Handle = i32;
export type Handle = TargetType<typeof Handle>;
export const Char8 = u8;
export type Char8 = TargetType<typeof Char8>;
export const Char32 = u32;
export type Char32 = TargetType<typeof Char32>;

export type WasiStringBytesPtr = ptr<Char8>;

export type WasiMutSlice<T> = usize;
export type WasiSlice<T> = usize;

/*
 * ---------------------- Module: [wasi_snapshot_preview1] ----------------------
 */

export const Size = u32;
export type Size = TargetType<typeof u32>;

/**
 * Non-negative file size or length of a region within a file.
 */
export const Filesize = u64;
export type Filesize = TargetType<typeof u64>;

/**
 * Timestamp in nanoseconds.
 */
export const Timestamp = u64;
export type Timestamp = TargetType<typeof u64>;

/**
 * Identifiers for clocks.
 */
export const Clockid = enumer<ClockidN>(u32);
export type Clockid = TargetType<typeof Clockid>;

export const enum ClockidN {
    /**
     * The clock measuring real time. Time value zero corresponds with
     * 1970-01-01T00:00:00Z.
     */
    REALTIME = 0,
    /**
     * The store-wide monotonic clock, which is defined as a clock measuring
     * real time, whose value cannot be adjusted and which cannot have negative
     * clock jumps. The epoch of this clock is undefined. The absolute time
     * value of this clock therefore has no meaning.
     */
    MONOTONIC = 1,
    /**
     * The CPU-time clock associated with the current process.
     */
    PROCESS_CPUTIME_ID = 2,
    /**
     * The CPU-time clock associated with the current thread.
     */
    THREAD_CPUTIME_ID = 3,
}

/**
 * Error codes returned by functions.
 * Not all of these error codes are returned by the functions provided by this
 * API; some are used in higher-level library layers, and others are provided
 * merely for alignment with POSIX.
 */
export const Errno = enumer<ErrnoN>(u16);
export type Errno = TargetType<typeof Errno>;

export const enum ErrnoN {
    /**
     * No error occurred. System call completed successfully.
     */
    SUCCESS = 0,
    /**
     * Argument list too long.
     */
    E_2_BIG = 1,
    /**
     * Permission denied.
     */
    ACCES = 2,
    /**
     * Address in use.
     */
    ADDRINUSE = 3,
    /**
     * Address not available.
     */
    ADDRNOTAVAIL = 4,
    /**
     * Address family not supported.
     */
    AFNOSUPPORT = 5,
    /**
     * Resource unavailable, or operation would block.
     */
    AGAIN = 6,
    /**
     * Connection already in progress.
     */
    ALREADY = 7,
    /**
     * Bad file descriptor.
     */
    BADF = 8,
    /**
     * Bad message.
     */
    BADMSG = 9,
    /**
     * Device or resource busy.
     */
    BUSY = 10,
    /**
     * Operation canceled.
     */
    CANCELED = 11,
    /**
     * No child processes.
     */
    CHILD = 12,
    /**
     * Connection aborted.
     */
    CONNABORTED = 13,
    /**
     * Connection refused.
     */
    CONNREFUSED = 14,
    /**
     * Connection reset.
     */
    CONNRESET = 15,
    /**
     * Resource deadlock would occur.
     */
    DEADLK = 16,
    /**
     * Destination address required.
     */
    DESTADDRREQ = 17,
    /**
     * Mathematics argument out of domain of function.
     */
    DOM = 18,
    /**
     * Reserved.
     */
    DQUOT = 19,
    /**
     * File exists.
     */
    EXIST = 20,
    /**
     * Bad address.
     */
    FAULT = 21,
    /**
     * File too large.
     */
    FBIG = 22,
    /**
     * Host is unreachable.
     */
    HOSTUNREACH = 23,
    /**
     * Identifier removed.
     */
    IDRM = 24,
    /**
     * Illegal byte sequence.
     */
    ILSEQ = 25,
    /**
     * Operation in progress.
     */
    INPROGRESS = 26,
    /**
     * Interrupted function.
     */
    INTR = 27,
    /**
     * Invalid argument.
     */
    INVAL = 28,
    /**
     * I/O error.
     */
    IO = 29,
    /**
     * Socket is connected.
     */
    ISCONN = 30,
    /**
     * Is a directory.
     */
    ISDIR = 31,
    /**
     * Too many levels of symbolic links.
     */
    LOOP = 32,
    /**
     * File descriptor value too large.
     */
    MFILE = 33,
    /**
     * Too many links.
     */
    MLINK = 34,
    /**
     * Message too large.
     */
    MSGSIZE = 35,
    /**
     * Reserved.
     */
    MULTIHOP = 36,
    /**
     * Filename too long.
     */
    NAMETOOLONG = 37,
    /**
     * Network is down.
     */
    NETDOWN = 38,
    /**
     * Connection aborted by network.
     */
    NETRESET = 39,
    /**
     * Network unreachable.
     */
    NETUNREACH = 40,
    /**
     * Too many files open in system.
     */
    NFILE = 41,
    /**
     * No buffer space available.
     */
    NOBUFS = 42,
    /**
     * No such device.
     */
    NODEV = 43,
    /**
     * No such file or directory.
     */
    NOENT = 44,
    /**
     * Executable file format error.
     */
    NOEXEC = 45,
    /**
     * No locks available.
     */
    NOLCK = 46,
    /**
     * Reserved.
     */
    NOLINK = 47,
    /**
     * Not enough space.
     */
    NOMEM = 48,
    /**
     * No message of the desired type.
     */
    NOMSG = 49,
    /**
     * Protocol not available.
     */
    NOPROTOOPT = 50,
    /**
     * No space left on device.
     */
    NOSPC = 51,
    /**
     * Function not supported.
     */
    NOSYS = 52,
    /**
     * The socket is not connected.
     */
    NOTCONN = 53,
    /**
     * Not a directory or a symbolic link to a directory.
     */
    NOTDIR = 54,
    /**
     * Directory not empty.
     */
    NOTEMPTY = 55,
    /**
     * State not recoverable.
     */
    NOTRECOVERABLE = 56,
    /**
     * Not a socket.
     */
    NOTSOCK = 57,
    /**
     * Not supported, or operation not supported on socket.
     */
    NOTSUP = 58,
    /**
     * Inappropriate I/O control operation.
     */
    NOTTY = 59,
    /**
     * No such device or address.
     */
    NXIO = 60,
    /**
     * Value too large to be stored in data type.
     */
    OVERFLOW = 61,
    /**
     * Previous owner died.
     */
    OWNERDEAD = 62,
    /**
     * Operation not permitted.
     */
    PERM = 63,
    /**
     * Broken pipe.
     */
    PIPE = 64,
    /**
     * Protocol error.
     */
    PROTO = 65,
    /**
     * Protocol not supported.
     */
    PROTONOSUPPORT = 66,
    /**
     * Protocol wrong type for socket.
     */
    PROTOTYPE = 67,
    /**
     * Result too large.
     */
    RANGE = 68,
    /**
     * Read-only file system.
     */
    ROFS = 69,
    /**
     * Invalid seek.
     */
    SPIPE = 70,
    /**
     * No such process.
     */
    SRCH = 71,
    /**
     * Reserved.
     */
    STALE = 72,
    /**
     * Connection timed out.
     */
    TIMEDOUT = 73,
    /**
     * Text file busy.
     */
    TXTBSY = 74,
    /**
     * Cross-device link.
     */
    XDEV = 75,
    /**
     * Extension: Capabilities insufficient.
     */
    NOTCAPABLE = 76,
}

/**
 * File descriptor rights, determining which actions may be performed.
 */
export const Rights = u64;
export type Rights = TargetType<typeof u64>;

export const RightsN = {
    /**
     * The right to invoke `fd_datasync`.
     * If `path_open` is set, includes the right to invoke
     * `path_open` with `fdflags::dsync`.
     */
    FD_DATASYNC: 0x1n,
    /**
     * The right to invoke `fd_read` and `sock_recv`.
     * If `rights::fd_seek` is set, includes the right to invoke `fd_pread`.
     */
    FD_READ: 0x2n,
    /**
     * The right to invoke `fd_seek`. This flag implies `rights::fd_tell`.
     */
    FD_SEEK: 0x4n,
    /**
     * The right to invoke `fd_fdstat_set_flags`.
     */
    FD_FDSTAT_SET_FLAGS: 0x8n,
    /**
     * The right to invoke `fd_sync`.
     * If `path_open` is set, includes the right to invoke
     * `path_open` with `fdflags::rsync` and `fdflags::dsync`.
     */
    FD_SYNC: 0x10n,
    /**
     * The right to invoke `fd_seek` in such a way that the file offset
     * remains unaltered (i.e., `whence::cur` with offset zero), or to
     * invoke `fd_tell`.
     */
    FD_TELL: 0x20n,
    /**
     * The right to invoke `fd_write` and `sock_send`.
     * If `rights::fd_seek` is set, includes the right to invoke `fd_pwrite`.
     */
    FD_WRITE: 0x40n,
    /**
     * The right to invoke `fd_advise`.
     */
    FD_ADVISE: 0x80n,
    /**
     * The right to invoke `fd_allocate`.
     */
    FD_ALLOCATE: 0x100n,
    /**
     * The right to invoke `path_create_directory`.
     */
    PATH_CREATE_DIRECTORY: 0x200n,
    /**
     * If `path_open` is set, the right to invoke `path_open` with `oflags::creat`.
     */
    PATH_CREATE_FILE: 0x400n,
    /**
     * The right to invoke `path_link` with the file descriptor as the
     * source directory.
     */
    PATH_LINK_SOURCE: 0x800n,
    /**
     * The right to invoke `path_link` with the file descriptor as the
     * target directory.
     */
    PATH_LINK_TARGET: 0x1000n,
    /**
     * The right to invoke `path_open`.
     */
    PATH_OPEN: 0x2000n,
    /**
     * The right to invoke `fd_readdir`.
     */
    FD_READDIR: 0x4000n,
    /**
     * The right to invoke `path_readlink`.
     */
    PATH_READLINK: 0x8000n,
    /**
     * The right to invoke `path_rename` with the file descriptor as the source directory.
     */
    PATH_RENAME_SOURCE: 0x10000n,
    /**
     * The right to invoke `path_rename` with the file descriptor as the target directory.
     */
    PATH_RENAME_TARGET: 0x20000n,
    /**
     * The right to invoke `path_filestat_get`.
     */
    PATH_FILESTAT_GET: 0x40000n,
    /**
     * The right to change a file's size (there is no `path_filestat_set_size`).
     * If `path_open` is set, includes the right to invoke `path_open` with `oflags::trunc`.
     */
    PATH_FILESTAT_SET_SIZE: 0x80000n,
    /**
     * The right to invoke `path_filestat_set_times`.
     */
    PATH_FILESTAT_SET_TIMES: 0x100000n,
    /**
     * The right to invoke `fd_filestat_get`.
     */
    FD_FILESTAT_GET: 0x200000n,
    /**
     * The right to invoke `fd_filestat_set_size`.
     */
    FD_FILESTAT_SET_SIZE: 0x400000n,
    /**
     * The right to invoke `fd_filestat_set_times`.
     */
    FD_FILESTAT_SET_TIMES: 0x800000n,
    /**
     * The right to invoke `path_symlink`.
     */
    PATH_SYMLINK: 0x1000000n,
    /**
     * The right to invoke `path_remove_directory`.
     */
    PATH_REMOVE_DIRECTORY: 0x2000000n,
    /**
     * The right to invoke `path_unlink_file`.
     */
    PATH_UNLINK_FILE: 0x4000000n,
    /**
     * If `rights::fd_read` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype::fd_read`.
     * If `rights::fd_write` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype::fd_write`.
     */
    POLL_FD_READWRITE: 0x8000000n,
    /**
     * The right to invoke `sock_shutdown`.
     */
    SOCK_SHUTDOWN: 0x10000000n,
    /**
     * The right to invoke `sock_accept`.
     */
    SOCK_ACCEPT: 0x20000000n,
};

/**
 * A file descriptor handle.
 */
export const Fd = Handle;
export type Fd = TargetType<typeof Handle>;

/**
 * A region of memory for scatter/gather reads.
 */
export const Iovec = struct({
    buf: usize,
    buf_len: Size,
});
export type Iovec = TargetType<typeof Iovec>;

/**
 * A region of memory for scatter/gather writes.
 */
export const Ciovec = struct({
    buf: usize,
    buf_len: Size,
});
export type Ciovec = TargetType<typeof Ciovec>;

export const IovecArray = usize;
export type IovecArray = TargetType<typeof usize>;

export const CiovecArray = usize;
export type CiovecArray = TargetType<typeof usize>;

/**
 * Relative offset within a file.
 */
export const Filedelta = i64;
export type Filedelta = TargetType<typeof i64>;

/**
 * The position relative to which to set the offset of the file descriptor.
 */
export const Whence = enumer<WhenceN>(u8);
export type Whence = TargetType<typeof Whence>;

export const enum WhenceN {
    /**
     * Seek relative to start-of-file.
     */
    SET = 0,
    /**
     * Seek relative to current position.
     */
    CUR = 1,
    /**
     * Seek relative to end-of-file.
     */
    END = 2,
}

/**
 * A reference to the offset of a directory entry.
 *
 * The value 0 signifies the start of the directory.
 */
export const Dircookie = u64;
export type Dircookie = TargetType<typeof u64>;

/**
 * The type for the `dirent::d_namlen` field of `dirent` struct.
 */
export const Dirnamlen = u32;
export type Dirnamlen = TargetType<typeof u32>;

/**
 * File serial number that is unique within its file system.
 */
export const Inode = u64;
export type Inode = TargetType<typeof u64>;

/**
 * The type of a file descriptor or file.
 */
export const Filetype = enumer<FiletypeN>(u8);
export type Filetype = TargetType<typeof Filetype>;

export const enum FiletypeN {
    /**
     * The type of the file descriptor or file is unknown or is different from any of the other types specified.
     */
    UNKNOWN = 0,
    /**
     * The file descriptor or file refers to a block device inode.
     */
    BLOCK_DEVICE = 1,
    /**
     * The file descriptor or file refers to a character device inode.
     */
    CHARACTER_DEVICE = 2,
    /**
     * The file descriptor or file refers to a directory inode.
     */
    DIRECTORY = 3,
    /**
     * The file descriptor or file refers to a regular file inode.
     */
    REGULAR_FILE = 4,
    /**
     * The file descriptor or file refers to a datagram socket.
     */
    SOCKET_DGRAM = 5,
    /**
     * The file descriptor or file refers to a byte-stream socket.
     */
    SOCKET_STREAM = 6,
    /**
     * The file refers to a symbolic link inode.
     */
    SYMBOLIC_LINK = 7,
}

/**
 * A directory entry.
 */
export const Dirent = struct({
    d_next: Dircookie,
    d_ino: Inode,
    d_namlen: Dirnamlen,
    d_type: Filetype,
});
export type Dirent = TargetType<typeof Dirent>;

/**
 * File or memory access pattern advisory information.
 */
export const Advice = enumer<AdviceN>(u8);
export type Advice = TargetType<typeof Advice>;

export const enum AdviceN {
    /**
     * The application has no advice to give on its behavior with respect to the specified data.
     */
    NORMAL = 0,
    /**
     * The application expects to access the specified data sequentially from lower offsets to higher offsets.
     */
    SEQUENTIAL = 1,
    /**
     * The application expects to access the specified data in a random order.
     */
    RANDOM = 2,
    /**
     * The application expects to access the specified data in the near future.
     */
    WILLNEED = 3,
    /**
     * The application expects that it will not access the specified data in the near future.
     */
    DONTNEED = 4,
    /**
     * The application expects to access the specified data once and then not reuse it thereafter.
     */
    NOREUSE = 5,
}

/**
 * File descriptor flags.
 */
export const Fdflags = u16;
export type Fdflags = TargetType<typeof u16>;

export const FdflagsN = {
    /**
     * Append mode: Data written to the file is always appended to the file's end.
     */
    APPEND: 0x1,
    /**
     * Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized.
     */
    DSYNC: 0x2,
    /**
     * Non-blocking mode.
     */
    NONBLOCK: 0x4,
    /**
     * Synchronized read I/O operations.
     */
    RSYNC: 0x8,
    /**
     * Write according to synchronized I/O file integrity completion. In
     * addition to synchronizing the data stored in the file, the implementation
     * may also synchronously update the file's metadata.
     */
    SYNC: 0x10,
};

/**
 * File descriptor attributes.
 */
export const Fdstat = struct({
    fs_filetype: Filetype,
    fs_flags: Fdflags,
    fs_rights_base: Rights,
    fs_rights_inheriting: Rights,
});
export type Fdstat = TargetType<typeof Fdstat>;

/**
 * Identifier for a device containing a file system. Can be used in combination
 * with `inode` to uniquely identify a file or directory in the filesystem.
 */
export const Device = u64;
export type Device = TargetType<typeof u64>;

/**
 * Which file time attributes to adjust.
 */
export const Fstflags = u16;
export type Fstflags = TargetType<typeof u16>;

export const FstflagsN = {
    /**
     * Adjust the last data access timestamp to the value stored in `filestat::atim`.
     */
    ATIM: 0x1,
    /**
     * Adjust the last data access timestamp to the time of clock `clockid::realtime`.
     */
    ATIM_NOW: 0x2,
    /**
     * Adjust the last data modification timestamp to the value stored in `filestat::mtim`.
     */
    MTIM: 0x4,
    /**
     * Adjust the last data modification timestamp to the time of clock `clockid::realtime`.
     */
    MTIM_NOW: 0x8,
};

/**
 * Flags determining the method of how paths are resolved.
 */
export const Lookupflags = u32;
export type Lookupflags = TargetType<typeof u32>;

export const LookupflagsN = {
    /**
     * As long as the resolved path corresponds to a symbolic link, it is expanded.
     */
    SYMLINK_FOLLOW: 1,
};

/**
 * Open flags used by `path_open`.
 */
export const Oflags = u16;
export type Oflags = TargetType<typeof u16>;

export const OflagsN = {
    /**
     * Create file if it does not exist.
     */
    CREAT: 0x1,
    /**
     * Fail if not a directory.
     */
    DIRECTORY: 0x2,
    /**
     * Fail if file already exists.
     */
    EXCL: 0x4,
    /**
     * Truncate file to size 0.
     */
    TRUNC: 0x8,
};

/**
 * Number of hard links to an inode.
 */
export const Linkcount = u64;
export type Linkcount = TargetType<typeof u64>;

/**
 * File attributes.
 */
export const Filestat = struct({
    dev: Device,
    ino: Inode,
    filetype: Filetype,
    nlink: Linkcount,
    size: Filesize,
    atim: Timestamp,
    mtim: Timestamp,
    ctim: Timestamp,
});
export type Filestat = TargetType<typeof Filestat>;

/**
 * User-provided value that may be attached to objects that is retained when
 * extracted from the implementation.
 */
export const Userdata = u64;
export type Userdata = TargetType<typeof u64>;

/**
 * Type of a subscription to an event or its occurrence.
 */
export const Eventtype = enumer<EventtypeN>(u8);
export type Eventtype = TargetType<typeof Eventtype>;

export const enum EventtypeN {
    /**
     * The time value of clock `subscription_clock::id` has
     * reached timestamp `subscription_clock::timeout`.
     */
    CLOCK = 0,
    /**
     * File descriptor `subscription_fd_readwrite::file_descriptor` has data
     * available for reading. This event always triggers for regular files.
     */
    FD_READ = 1,
    /**
     * File descriptor `subscription_fd_readwrite::file_descriptor` has capacity
     * available for writing. This event always triggers for regular files.
     */
    FD_WRITE = 2,
}

/**
 * The state of the file descriptor subscribed to with
 * `eventtype::fd_read` or `eventtype::fd_write`.
 */
export const Eventrwflags = u16;
export type Eventrwflags = TargetType<typeof u16>;

export const EventrwflagsN = {
    /**
     * The peer of this socket has closed or disconnected.
     */
    FD_READWRITE_HANGUP: 1,
};

/**
 * The contents of an `event` when type is `eventtype::fd_read` or
 * `eventtype::fd_write`.
 */
export const EventFdReadwrite = struct({
    nbytes: Filesize,
    flags: Eventrwflags,
});
export type EventFdReadwrite = TargetType<typeof EventFdReadwrite>;

/**
 * An event that occurred.
 */
export const Event = struct({
    userdata: Userdata,
    error: Errno,
    type: Eventtype,
    fd_readwrite: EventFdReadwrite,
});
export type Event = TargetType<typeof Event>;

/**
 * Flags determining how to interpret the timestamp provided in
 * `subscription_clock::timeout`.
 */
export const Subclockflags = u16;
export type Subclockflags = TargetType<typeof u16>;

export const SubclockflagsN = {
    /**
     * If set, treat the timestamp provided in
     * `subscription_clock::timeout` as an absolute timestamp of clock
     * `subscription_clock::id`. If clear, treat the timestamp
     * provided in `subscription_clock::timeout` relative to the
     * current time value of clock `subscription_clock::id`.
     */
    SUBSCRIPTION_CLOCK_ABSTIME: 1,
};

/**
 * The contents of a `subscription` when type is `eventtype::clock`.
 */
export const SubscriptionClock = struct({
    id: Clockid,
    timeout: Timestamp,
    precision: Timestamp,
    flags: Subclockflags,
});
export type SubscriptionClock = TargetType<typeof SubscriptionClock>;

/**
 * The contents of a `subscription` when type is type is
 * `eventtype::fd_read` or `eventtype::fd_write`.
 */
export const SubscriptionFdReadwrite = struct({
    file_descriptor: Fd,
});
export type SubscriptionFdReadwrite = TargetType<typeof SubscriptionFdReadwrite>;

/**
 * The contents of a `subscription`.
 */
export const SubscriptionU = taggedUnion({
    tag: Eventtype,
    data: {
        [EventtypeN.CLOCK]: SubscriptionClock,
        [EventtypeN.FD_READ]: SubscriptionFdReadwrite,
        [EventtypeN.FD_WRITE]: SubscriptionFdReadwrite,
    },
});
export type SubscriptionU = TargetType<typeof SubscriptionU>;

/**
 * Subscription to an event.
 */
export const Subscription = struct({
    userdata: Userdata,
    u: SubscriptionU,
});
export type Subscription = TargetType<typeof Subscription>;

/**
 * Exit code generated by a process when exiting.
 */
export const Exitcode = u32;
export type Exitcode = TargetType<typeof u32>;

/**
 * Signal condition.
 */
export const Signal = enumer<SignalN>(u8);
export type Signal = TargetType<typeof Signal>;

export const enum SignalN {
    /**
     * No signal. Note that POSIX has special semantics for `kill(pid, 0)`,
     * so this value is reserved.
     */
    NONE = 0,
    /**
     * Hangup.
     * Action: Terminates the process.
     */
    HUP = 1,
    /**
     * Terminate interrupt signal.
     * Action: Terminates the process.
     */
    INT = 2,
    /**
     * Terminal quit signal.
     * Action: Terminates the process.
     */
    QUIT = 3,
    /**
     * Illegal instruction.
     * Action: Terminates the process.
     */
    ILL = 4,
    /**
     * Trace/breakpoint trap.
     * Action: Terminates the process.
     */
    TRAP = 5,
    /**
     * Process abort signal.
     * Action: Terminates the process.
     */
    ABRT = 6,
    /**
     * Access to an undefined portion of a memory object.
     * Action: Terminates the process.
     */
    BUS = 7,
    /**
     * Erroneous arithmetic operation.
     * Action: Terminates the process.
     */
    FPE = 8,
    /**
     * Kill.
     * Action: Terminates the process.
     */
    KILL = 9,
    /**
     * User-defined signal 1.
     * Action: Terminates the process.
     */
    USR_1 = 10,
    /**
     * Invalid memory reference.
     * Action: Terminates the process.
     */
    SEGV = 11,
    /**
     * User-defined signal 2.
     * Action: Terminates the process.
     */
    USR_2 = 12,
    /**
     * Write on a pipe with no one to read it.
     * Action: Ignored.
     */
    PIPE = 13,
    /**
     * Alarm clock.
     * Action: Terminates the process.
     */
    ALRM = 14,
    /**
     * Termination signal.
     * Action: Terminates the process.
     */
    TERM = 15,
    /**
     * Child process terminated, stopped, or continued.
     * Action: Ignored.
     */
    CHLD = 16,
    /**
     * Continue executing, if stopped.
     * Action: Continues executing, if stopped.
     */
    CONT = 17,
    /**
     * Stop executing.
     * Action: Stops executing.
     */
    STOP = 18,
    /**
     * Terminal stop signal.
     * Action: Stops executing.
     */
    TSTP = 19,
    /**
     * Background process attempting read.
     * Action: Stops executing.
     */
    TTIN = 20,
    /**
     * Background process attempting write.
     * Action: Stops executing.
     */
    TTOU = 21,
    /**
     * High bandwidth data is available at a socket.
     * Action: Ignored.
     */
    URG = 22,
    /**
     * CPU time limit exceeded.
     * Action: Terminates the process.
     */
    XCPU = 23,
    /**
     * File size limit exceeded.
     * Action: Terminates the process.
     */
    XFSZ = 24,
    /**
     * Virtual timer expired.
     * Action: Terminates the process.
     */
    VTALRM = 25,
    /**
     * Profiling timer expired.
     * Action: Terminates the process.
     */
    PROF = 26,
    /**
     * Window changed.
     * Action: Ignored.
     */
    WINCH = 27,
    /**
     * I/O possible.
     * Action: Terminates the process.
     */
    POLL = 28,
    /**
     * Power failure.
     * Action: Terminates the process.
     */
    PWR = 29,
    /**
     * Bad system call.
     * Action: Terminates the process.
     */
    SYS = 30,
}

/**
 * Flags provided to `sock_recv`.
 */
export const Riflags = u16;
export type Riflags = TargetType<typeof u16>;

export const RiflagsN = {
    /**
     * Returns the message without removing it from the socket's receive queue.
     */
    RECV_PEEK: 1,
    /**
     * On byte-stream sockets, block until the full amount of data can be returned.
     */
    RECV_WAITALL: 2,
};

/**
 * Flags returned by `sock_recv`.
 */
export const Roflags = u16;
export type Roflags = TargetType<typeof u16>;

export const RoflagsN = {
    /**
     * Returned by `sock_recv`: Message data has been truncated.
     */
    RECV_DATA_TRUNCATED: 1,
};

/**
 * Flags provided to `sock_send`. As there are currently no flags
 * defined, it must be set to zero.
 */
export const Siflags = u16;
export type Siflags = TargetType<typeof u16>;

/**
 * Which channels on a socket to shut down.
 */
export const Sdflags = u8;
export type Sdflags = TargetType<typeof u8>;

export const SdflagsN = {
    /**
     * Disables further receive operations.
     */
    RD: 1,
    /**
     * Disables further send operations.
     */
    WR: 2,
};

/**
 * Identifiers for preopened capabilities.
 */
export const Preopentype = enumer<PreopentypeN>(u8);
export type Preopentype = TargetType<typeof Preopentype>;

export const enum PreopentypeN {
    /**
     * A pre-opened directory.
     */
    DIR = 0,
}

/**
 * The contents of a $prestat when type is `preopentype::dir`.
 */
export const PrestatDir = struct({
    pr_name_len: Size,
});
export type PrestatDir = TargetType<typeof PrestatDir>;

/**
 * Information about a pre-opened capability.
 */
export const Prestat = taggedUnion({
    tag: Preopentype,
    data: {
        [PreopentypeN.DIR]: PrestatDir,
    },
});
export type Prestat = TargetType<typeof Prestat>;

export interface WasiSnapshotPreview1Async {
    /**
     * Read command-line argument data.
     * The size of the array should match that returned by `args_sizes_get`.
     * Each argument is expected to be `\0` terminated.
     */
    argsGet(argv: mutptr<mutptr<u8>>, argv_buf: mutptr<u8>): Promise<Errno>;

    /**
     * Return command-line argument data sizes.
     */
    argsSizesGet(result_0_ptr: mutptr<Size>, result_1_ptr: mutptr<Size>): Promise<Errno>;

    /**
     * Read environment variable data.
     * The sizes of the buffers should match that returned by `environ_sizes_get`.
     * Key/value pairs are expected to be joined with `=`s, and terminated with `\0`s.
     */
    environGet(environ: mutptr<mutptr<u8>>, environ_buf: mutptr<u8>): Promise<Errno>;

    /**
     * Return environment variable data sizes.
     */
    environSizesGet(result_0_ptr: mutptr<Size>, result_1_ptr: mutptr<Size>): Promise<Errno>;

    /**
     * Return the resolution of a clock.
     * Implementations are required to provide a non-zero value for supported clocks. For unsupported clocks,
     * return `errno::inval`.
     * Note: This is similar to `clock_getres` in POSIX.
     */
    clockResGet(id: Clockid, result_ptr: mutptr<Timestamp>): Promise<Errno>;

    /**
     * Return the time value of a clock.
     * Note: This is similar to `clock_gettime` in POSIX.
     */
    clockTimeGet(id: Clockid, precision: Timestamp, result_ptr: mutptr<Timestamp>): Promise<Errno>;

    /**
     * Provide file advisory information on a file descriptor.
     * Note: This is similar to `posix_fadvise` in POSIX.
     */
    fdAdvise(fd: Fd, offset: Filesize, len: Filesize, advice: Advice): Promise<Errno>;

    /**
     * Force the allocation of space in a file.
     * Note: This is similar to `posix_fallocate` in POSIX.
     */
    fdAllocate(fd: Fd, offset: Filesize, len: Filesize): Promise<Errno>;

    /**
     * Close a file descriptor.
     * Note: This is similar to `close` in POSIX.
     */
    fdClose(fd: Fd): Promise<Errno>;

    /**
     * Synchronize the data of a file to disk.
     * Note: This is similar to `fdatasync` in POSIX.
     */
    fdDatasync(fd: Fd): Promise<Errno>;

    /**
     * Get the attributes of a file descriptor.
     * Note: This returns similar flags to `fsync(fd, F_GETFL)` in POSIX, as well as additional fields.
     */
    fdFdstatGet(fd: Fd, result_ptr: mutptr<Fdstat>): Promise<Errno>;

    /**
     * Adjust the flags associated with a file descriptor.
     * Note: This is similar to `fcntl(fd, F_SETFL, flags)` in POSIX.
     */
    fdFdstatSetFlags(fd: Fd, flags: Fdflags): Promise<Errno>;

    /**
     * Adjust the rights associated with a file descriptor.
     * This can only be used to remove rights, and returns `errno::notcapable` if called in a way that would attempt to add rights
     */
    fdFdstatSetRights(fd: Fd, fs_rights_base: Rights, fs_rights_inheriting: Rights): Promise<Errno>;

    /**
     * Return the attributes of an open file.
     */
    fdFilestatGet(fd: Fd, result_ptr: mutptr<Filestat>): Promise<Errno>;

    /**
     * Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros.
     * Note: This is similar to `ftruncate` in POSIX.
     */
    fdFilestatSetSize(fd: Fd, size: Filesize): Promise<Errno>;

    /**
     * Adjust the timestamps of an open file or directory.
     * Note: This is similar to `futimens` in POSIX.
     */
    fdFilestatSetTimes(fd: Fd, atim: Timestamp, mtim: Timestamp, fst_flags: Fstflags): Promise<Errno>;

    /**
     * Read from a file descriptor, without using and updating the file descriptor's offset.
     * Note: This is similar to `preadv` in POSIX.
     */
    fdPread(fd: Fd, iovs_ptr: ptr<Iovec>, iovs_len: usize, offset: Filesize, result_ptr: mutptr<Size>): Promise<Errno>;

    /**
     * Return a description of the given preopened file descriptor.
     */
    fdPrestatGet(fd: Fd, result_ptr: mutptr<Prestat>): Promise<Errno>;

    /**
     * Return a description of the given preopened file descriptor.
     */
    fdPrestatDirName(fd: Fd, path: mutptr<u8>, path_len: Size): Promise<Errno>;

    /**
     * Write to a file descriptor, without using and updating the file descriptor's offset.
     * Note: This is similar to `pwritev` in POSIX.
     */
    fdPwrite(
        fd: Fd,
        iovs_ptr: ptr<Ciovec>,
        iovs_len: usize,
        offset: Filesize,
        result_ptr: mutptr<Size>
    ): Promise<Errno>;

    /**
     * Read from a file descriptor.
     * Note: This is similar to `readv` in POSIX.
     */
    fdRead(fd: Fd, iovs_ptr: ptr<Iovec>, iovs_len: usize, result_ptr: mutptr<Size>): Promise<Errno>;

    /**
     * Read directory entries from a directory.
     * When successful, the contents of the output buffer consist of a sequence of
     * directory entries. Each directory entry consists of a `dirent` object,
     * followed by `dirent::d_namlen` bytes holding the name of the directory
     * entry.
     * This function fills the output buffer as much as possible, potentially
     * truncating the last directory entry. This allows the caller to grow its
     * read buffer size in case it's too small to fit a single large directory
     * entry, or skip the oversized directory entry.
     */
    fdReaddir(fd: Fd, buf: mutptr<u8>, buf_len: Size, cookie: Dircookie, result_ptr: mutptr<Size>): Promise<Errno>;

    /**
     * Atomically replace a file descriptor by renumbering another file descriptor.
     * Due to the strong focus on thread safety, this environment does not provide
     * a mechanism to duplicate or renumber a file descriptor to an arbitrary
     * number, like `dup2()`. This would be prone to race conditions, as an actual
     * file descriptor with the same number could be allocated by a different
     * thread at the same time.
     * This function provides a way to atomically renumber file descriptors, which
     * would disappear if `dup2()` were to be removed entirely.
     */
    fdRenumber(fd: Fd, to: Fd): Promise<Errno>;

    /**
     * Move the offset of a file descriptor.
     * Note: This is similar to `lseek` in POSIX.
     */
    fdSeek(fd: Fd, offset: Filedelta, whence: Whence, result_ptr: mutptr<Filesize>): Promise<Errno>;

    /**
     * Synchronize the data and metadata of a file to disk.
     * Note: This is similar to `fsync` in POSIX.
     */
    fdSync(fd: Fd): Promise<Errno>;

    /**
     * Return the current offset of a file descriptor.
     * Note: This is similar to `lseek(fd, 0, SEEK_CUR)` in POSIX.
     */
    fdTell(fd: Fd, result_ptr: mutptr<Filesize>): Promise<Errno>;

    /**
     * Write to a file descriptor.
     * Note: This is similar to `writev` in POSIX.
     */
    fdWrite(fd: Fd, iovs_ptr: ptr<Ciovec>, iovs_len: usize, result_ptr: mutptr<Size>): Promise<Errno>;

    /**
     * Create a directory.
     * Note: This is similar to `mkdirat` in POSIX.
     */
    pathCreateDirectory(fd: Fd, path_ptr: ptr<string>, path_len: usize): Promise<Errno>;

    /**
     * Return the attributes of a file or directory.
     * Note: This is similar to `stat` in POSIX.
     */
    pathFilestatGet(
        fd: Fd,
        flags: Lookupflags,
        path_ptr: ptr<string>,
        path_len: usize,
        result_ptr: mutptr<Filestat>
    ): Promise<Errno>;

    /**
     * Adjust the timestamps of a file or directory.
     * Note: This is similar to `utimensat` in POSIX.
     */
    pathFilestatSetTimes(
        fd: Fd,
        flags: Lookupflags,
        path_ptr: ptr<string>,
        path_len: usize,
        atim: Timestamp,
        mtim: Timestamp,
        fst_flags: Fstflags
    ): Promise<Errno>;

    /**
     * Create a hard link.
     * Note: This is similar to `linkat` in POSIX.
     */
    pathLink(
        old_fd: Fd,
        old_flags: Lookupflags,
        old_path_ptr: ptr<string>,
        old_path_len: usize,
        new_fd: Fd,
        new_path_ptr: ptr<string>,
        new_path_len: usize
    ): Promise<Errno>;

    /**
     * Open a file or directory.
     * The returned file descriptor is not guaranteed to be the lowest-numbered
     * file descriptor not currently open; it is randomized to prevent
     * applications from depending on making assumptions about indexes, since this
     * is error-prone in multi-threaded contexts. The returned file descriptor is
     * guaranteed to be less than 2**31.
     * Note: This is similar to `openat` in POSIX.
     */
    pathOpen(
        fd: Fd,
        dirflags: Lookupflags,
        path_ptr: ptr<string>,
        path_len: usize,
        oflags: Oflags,
        fs_rights_base: Rights,
        fs_rights_inheriting: Rights,
        fdflags: Fdflags,
        result_ptr: mutptr<Fd>
    ): Promise<Errno>;

    /**
     * Read the contents of a symbolic link.
     * Note: This is similar to `readlinkat` in POSIX.
     */
    pathReadlink(
        fd: Fd,
        path_ptr: ptr<string>,
        path_len: usize,
        buf: mutptr<u8>,
        buf_len: Size,
        result_ptr: mutptr<Size>
    ): Promise<Errno>;

    /**
     * Remove a directory.
     * Return `errno::notempty` if the directory is not empty.
     * Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
     */
    pathRemoveDirectory(fd: Fd, path_ptr: ptr<string>, path_len: usize): Promise<Errno>;

    /**
     * Rename a file or directory.
     * Note: This is similar to `renameat` in POSIX.
     */
    pathRename(
        fd: Fd,
        old_path_ptr: ptr<string>,
        old_path_len: usize,
        new_fd: Fd,
        new_path_ptr: ptr<string>,
        new_path_len: usize
    ): Promise<Errno>;

    /**
     * Create a symbolic link.
     * Note: This is similar to `symlinkat` in POSIX.
     */
    pathSymlink(
        old_path_ptr: ptr<string>,
        old_path_len: usize,
        fd: Fd,
        new_path_ptr: ptr<string>,
        new_path_len: usize
    ): Promise<Errno>;

    /**
     * Unlink a file.
     * Return `errno::isdir` if the path refers to a directory.
     * Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
     */
    pathUnlinkFile(fd: Fd, path_ptr: ptr<string>, path_len: usize): Promise<Errno>;

    /**
     * Concurrently poll for the occurrence of a set of events.
     */
    pollOneoff(
        in_: ptr<Subscription>,
        out: mutptr<Event>,
        nsubscriptions: Size,
        result_ptr: mutptr<Size>
    ): Promise<Errno>;

    /**
     * Terminate the process normally. An exit code of 0 indicates successful
     * termination of the program. The meanings of other values is dependent on
     * the environment.
     */
    procExit(rval: Exitcode): Promise<void>;

    /**
     * Send a signal to the process of the calling thread.
     * Note: This is similar to `raise` in POSIX.
     */
    procRaise(sig: Signal): Promise<Errno>;

    /**
     * Temporarily yield execution of the calling thread.
     * Note: This is similar to `sched_yield` in POSIX.
     */
    schedYield(): Promise<Errno>;

    /**
     * Write high-quality random data into a buffer.
     * This function blocks when the implementation is unable to immediately
     * provide sufficient high-quality random data.
     * This function may execute slowly, so when large mounts of random data are
     * required, it's advisable to use this function to seed a pseudo-random
     * number generator, rather than to provide the random data directly.
     */
    randomGet(buf: mutptr<u8>, buf_len: Size): Promise<Errno>;

    /**
     * Accept a new incoming connection.
     * Note: This is similar to `accept` in POSIX.
     */
    sockAccept(fd: Fd, flags: Fdflags, result_ptr: mutptr<Fd>): Promise<Errno>;

    /**
     * Receive a message from a socket.
     * Note: This is similar to `recv` in POSIX, though it also supports reading
     * the data into multiple buffers in the manner of `readv`.
     */
    sockRecv(
        fd: Fd,
        ri_data_ptr: ptr<Iovec>,
        ri_data_len: usize,
        ri_flags: Riflags,
        result_0_ptr: mutptr<Size>,
        result_1_ptr: mutptr<Roflags>
    ): Promise<Errno>;

    /**
     * Send a message on a socket.
     * Note: This is similar to `send` in POSIX, though it also supports writing
     * the data from multiple buffers in the manner of `writev`.
     */
    sockSend(
        fd: Fd,
        si_data_ptr: ptr<Ciovec>,
        si_data_len: usize,
        si_flags: Siflags,
        result_ptr: mutptr<Size>
    ): Promise<Errno>;

    /**
     * Shut down socket send and receive channels.
     * Note: This is similar to `shutdown` in POSIX.
     */
    sockShutdown(fd: Fd, how: Sdflags): Promise<Errno>;
}

export interface WasiSnapshotPreview1Handler {
    getExport(name: string): WebAssembly.ExportValue;
    handleError(err: any): number;
    checkAbort(): void;
}

export function addWasiSnapshotPreview1ToImports(
    imports: any,
    obj: WasiSnapshotPreview1Async,
    handler: WasiSnapshotPreview1Handler
): void {
    if (!("wasi_snapshot_preview1" in imports)) imports["wasi_snapshot_preview1"] = {};
    imports["wasi_snapshot_preview1"]["args_get"] = async function (_argv: any, _argv_buf: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.argsGet(_argv, _argv_buf);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["args_sizes_get"] = async function (_result_0_ptr: any, _result_1_ptr: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.argsSizesGet(_result_0_ptr, _result_1_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["environ_get"] = async function (_environ: any, _environ_buf: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.environGet(_environ, _environ_buf);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["environ_sizes_get"] = async function (_result_0_ptr: any, _result_1_ptr: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.environSizesGet(_result_0_ptr, _result_1_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["clock_res_get"] = async function (_id: any, _result_ptr: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.clockResGet(_id, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["clock_time_get"] = async function (_id: any, _precision: any, _result_ptr: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.clockTimeGet(_id, _precision, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_advise"] = async function (_fd: any, _offset: any, _len: any, _advice: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdAdvise(_fd, _offset, _len, _advice);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_allocate"] = async function (_fd: any, _offset: any, _len: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdAllocate(_fd, _offset, _len);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_close"] = async function (_fd: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdClose(_fd);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_datasync"] = async function (_fd: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdDatasync(_fd);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_fdstat_get"] = async function (_fd: any, _result_ptr: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdFdstatGet(_fd, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_fdstat_set_flags"] = async function (_fd: any, _flags: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdFdstatSetFlags(_fd, _flags);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_fdstat_set_rights"] = async function (
        _fd: any,
        _fs_rights_base: any,
        _fs_rights_inheriting: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdFdstatSetRights(_fd, _fs_rights_base, _fs_rights_inheriting);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_filestat_get"] = async function (_fd: any, _result_ptr: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdFilestatGet(_fd, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_filestat_set_size"] = async function (_fd: any, _size: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdFilestatSetSize(_fd, _size);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_filestat_set_times"] = async function (
        _fd: any,
        _atim: any,
        _mtim: any,
        _fst_flags: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdFilestatSetTimes(_fd, _atim, _mtim, _fst_flags);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_pread"] = async function (
        _fd: any,
        _iovs_ptr: any,
        _iovs_len: any,
        _offset: any,
        _result_ptr: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdPread(_fd, _iovs_ptr, _iovs_len, _offset, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_prestat_get"] = async function (_fd: any, _result_ptr: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdPrestatGet(_fd, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_prestat_dir_name"] = async function (_fd: any, _path: any, _path_len: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdPrestatDirName(_fd, _path, _path_len);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_pwrite"] = async function (
        _fd: any,
        _iovs_ptr: any,
        _iovs_len: any,
        _offset: any,
        _result_ptr: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdPwrite(_fd, _iovs_ptr, _iovs_len, _offset, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_read"] = async function (
        _fd: any,
        _iovs_ptr: any,
        _iovs_len: any,
        _result_ptr: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdRead(_fd, _iovs_ptr, _iovs_len, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_readdir"] = async function (
        _fd: any,
        _buf: any,
        _buf_len: any,
        _cookie: any,
        _result_ptr: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdReaddir(_fd, _buf, _buf_len, _cookie, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_renumber"] = async function (_fd: any, _to: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdRenumber(_fd, _to);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_seek"] = async function (
        _fd: any,
        _offset: any,
        _whence: any,
        _result_ptr: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdSeek(_fd, _offset, _whence, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_sync"] = async function (_fd: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdSync(_fd);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_tell"] = async function (_fd: any, _result_ptr: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdTell(_fd, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["fd_write"] = async function (
        _fd: any,
        _iovs_ptr: any,
        _iovs_len: any,
        _result_ptr: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.fdWrite(_fd, _iovs_ptr, _iovs_len, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["path_create_directory"] = async function (
        _fd: any,
        _path_ptr: any,
        _path_len: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.pathCreateDirectory(_fd, _path_ptr, _path_len);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["path_filestat_get"] = async function (
        _fd: any,
        _flags: any,
        _path_ptr: any,
        _path_len: any,
        _result_ptr: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.pathFilestatGet(_fd, _flags, _path_ptr, _path_len, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["path_filestat_set_times"] = async function (
        _fd: any,
        _flags: any,
        _path_ptr: any,
        _path_len: any,
        _atim: any,
        _mtim: any,
        _fst_flags: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.pathFilestatSetTimes(_fd, _flags, _path_ptr, _path_len, _atim, _mtim, _fst_flags);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["path_link"] = async function (
        _old_fd: any,
        _old_flags: any,
        _old_path_ptr: any,
        _old_path_len: any,
        _new_fd: any,
        _new_path_ptr: any,
        _new_path_len: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.pathLink(
                _old_fd,
                _old_flags,
                _old_path_ptr,
                _old_path_len,
                _new_fd,
                _new_path_ptr,
                _new_path_len
            );
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["path_open"] = async function (
        _fd: any,
        _dirflags: any,
        _path_ptr: any,
        _path_len: any,
        _oflags: any,
        _fs_rights_base: any,
        _fs_rights_inheriting: any,
        _fdflags: any,
        _result_ptr: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.pathOpen(
                _fd,
                _dirflags,
                _path_ptr,
                _path_len,
                _oflags,
                _fs_rights_base,
                _fs_rights_inheriting,
                _fdflags,
                _result_ptr
            );
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["path_readlink"] = async function (
        _fd: any,
        _path_ptr: any,
        _path_len: any,
        _buf: any,
        _buf_len: any,
        _result_ptr: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.pathReadlink(_fd, _path_ptr, _path_len, _buf, _buf_len, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["path_remove_directory"] = async function (
        _fd: any,
        _path_ptr: any,
        _path_len: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.pathRemoveDirectory(_fd, _path_ptr, _path_len);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["path_rename"] = async function (
        _fd: any,
        _old_path_ptr: any,
        _old_path_len: any,
        _new_fd: any,
        _new_path_ptr: any,
        _new_path_len: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.pathRename(_fd, _old_path_ptr, _old_path_len, _new_fd, _new_path_ptr, _new_path_len);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["path_symlink"] = async function (
        _old_path_ptr: any,
        _old_path_len: any,
        _fd: any,
        _new_path_ptr: any,
        _new_path_len: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.pathSymlink(_old_path_ptr, _old_path_len, _fd, _new_path_ptr, _new_path_len);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["path_unlink_file"] = async function (_fd: any, _path_ptr: any, _path_len: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.pathUnlinkFile(_fd, _path_ptr, _path_len);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["poll_oneoff"] = async function (
        _in_: any,
        _out: any,
        _nsubscriptions: any,
        _result_ptr: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.pollOneoff(_in_, _out, _nsubscriptions, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["proc_exit"] = async function (_rval: any) {
        const errorHandler2 = handler.handleError;
        try {
            await obj.procExit(_rval);
            handler.checkAbort();
        } catch (err: any) {
            const eRet = errorHandler2(err);
            console.log("wasi_snapshot_preview1 proc_exit handled error", err, eRet);
        }
    };
    imports["wasi_snapshot_preview1"]["proc_raise"] = async function (_sig: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.procRaise(_sig);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["sched_yield"] = async function () {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.schedYield();
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["random_get"] = async function (_buf: any, _buf_len: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.randomGet(_buf, _buf_len);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["sock_accept"] = async function (_fd: any, _flags: any, _result_ptr: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.sockAccept(_fd, _flags, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["sock_recv"] = async function (
        _fd: any,
        _ri_data_ptr: any,
        _ri_data_len: any,
        _ri_flags: any,
        _result_0_ptr: any,
        _result_1_ptr: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.sockRecv(_fd, _ri_data_ptr, _ri_data_len, _ri_flags, _result_0_ptr, _result_1_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["sock_send"] = async function (
        _fd: any,
        _si_data_ptr: any,
        _si_data_len: any,
        _si_flags: any,
        _result_ptr: any
    ) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.sockSend(_fd, _si_data_ptr, _si_data_len, _si_flags, _result_ptr);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
    imports["wasi_snapshot_preview1"]["sock_shutdown"] = async function (_fd: any, _how: any) {
        const errorHandler2 = handler.handleError;
        try {
            const ret = await obj.sockShutdown(_fd, _how);
            handler.checkAbort();
            return ret;
        } catch (err: any) {
            return errorHandler2(err);
        }
    };
}
