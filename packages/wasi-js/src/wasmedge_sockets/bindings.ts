
/*
 * This file was automatically generated by witx-codegen - Do not edit manually.
 */

// Pointer to target
export type ptr<T> = number & { _pointerTarget: T };
// Mutable pointer to target
export type mutptr<T> = ptr<T>;

// Type Definition for complex and simple types
export interface TypeDef<T> {
    size: number;
    align: number;
    
    get(buf: ArrayBuffer, ptr: ptr<T>): T;
    set(buf: ArrayBuffer, ptr: ptr<T>, value: T): void;
}
// Get target JS type of TypeDef
export type TargetType<D> = D extends TypeDef<infer T> ? T : never;
    
const getDataView = (() => {
    const cache = new WeakMap<ArrayBuffer, DataView>();
    
    return (buf: ArrayBuffer) => {
        let dataView = cache.get(buf);
        if (!dataView) {
        dataView = new DataView(buf);
        cache.set(buf, dataView);
        }
        return dataView;
    };
})();

// Function to get TypeDef for primitive JS types
function std<T = number>(name: string, size: number): TypeDef<T> {
    const get = (DataView.prototype as any)[`get${name}`];
    const set = (DataView.prototype as any)[`set${name}`];

    return {
        size,
        align: size,
        get(buf, ptr) {
            return get.call(getDataView(buf), ptr, true);
        },
        set(buf, ptr, value) {
            return set.call(getDataView(buf), ptr, value, true);
        },
    };
}

// Function for UTF-8 strings
export const string = (() => {
  const textEncoder = new TextEncoder();
  const textDecoder = new TextDecoder();

  return {
    get(buf: ArrayBuffer, ptr: ptr<string>, len: number): string {
      return textDecoder.decode(new Uint8Array(buf, ptr, len));
    },
    set(
      buf: ArrayBuffer,
      ptr: ptr<string>,
      value: string,
      len?: number | undefined
    ) {
      if (len) {
        const { read } = textEncoder.encodeInto(
          value,
          new Uint8Array(buf, ptr, len)
        );
        if (read! < value.length) {
          throw new Error(`Insufficient space.`);
        }
      } else {
        // we don't know the string length beforehand
        const src = textEncoder.encode(value);
        len = src.byteLength;
        const dst = new Uint8Array(buf, ptr, len);
        dst.set(src);
      }
    },
  };
})();
  
function alignTo(ptr: number, align: number): number {
  const mismatch = ptr % align;
  if (mismatch) {
    ptr += align - mismatch;
  }
  return ptr;
}
  
// To construct TypeDef for structs
export function struct<T extends Record<string, TypeDef<any>>>(
  desc: T
): TypeDef<{ [K in keyof T]: T[K] extends TypeDef<infer F> ? F : never }> {
  class Ctor {
    constructor(protected _buf: ArrayBuffer, protected _ptr: number) {}
  }
  let offset = 0;
  let structAlign = 0;
  for (const name in desc) {
    const type = desc[name];
    const fieldAlign = type.align;
    structAlign = Math.max(structAlign, fieldAlign);
    offset = alignTo(offset, fieldAlign);
    const fieldOffset = offset;
    Object.defineProperty(Ctor.prototype, name, {
      get(this: Ctor) {
        return type.get(this._buf, (this._ptr + fieldOffset) as ptr<any>);
      },
      set(this: Ctor, value) {
        type.set(this._buf, (this._ptr + fieldOffset) as ptr<any>, value);
      },
    });
    offset += type.size;
  }
  offset = alignTo(offset, structAlign);
  return {
    size: offset,
    align: structAlign,
    get(buf, ptr) {
      return new Ctor(buf, ptr) as any;
    },
    set(buf, ptr, value) {
      Object.assign(new Ctor(buf, ptr), value);
    },
  };
}

// To construct TypeDef for taggedUnion
export function taggedUnion<
  E extends number,
  T extends Record<E, TypeDef<any>>
>({
  tag: tagDesc,
  data: dataDesc,
}: {
  tag: TypeDef<E>;
  data: T;
}): TypeDef<
  {
    [K in E]: { tag: K; data: T[K] extends TypeDef<infer F> ? F : never };
  }[E]
> {
  let unionSize = 0;
  let unionAlign = 0;
  for (const key in dataDesc) {
    const { size, align } = dataDesc[key];
    unionSize = Math.max(unionSize, size);
    unionAlign = Math.max(unionAlign, align);
  }
  unionSize = alignTo(unionSize, unionAlign);
  const unionOffset = alignTo(tagDesc.size, unionAlign);
  const totalAlign = Math.max(tagDesc.align, unionAlign);
  const totalSize = alignTo(unionOffset + unionSize, totalAlign);
  return {
    size: totalSize,
    align: totalAlign,
    get(buf, ptr) {
      const tag = tagDesc.get(buf, ptr as ptr<any>);
      return {
        tag,
        data: dataDesc[tag].get(buf, (ptr + unionOffset) as ptr<any>),
      };
    },
    set(buf, ptr, value) {
      tagDesc.set(buf, ptr as ptr<any>, value.tag);
      dataDesc[value.tag].set(buf, (ptr + unionOffset) as ptr<any>, value.data);
    },
  };
}

// To construct TypeDef for enum
export function enumer<E extends number>(base: TypeDef<number>): TypeDef<E> {
  // All the properties are same as for the underlying number, this wrapper is only useful at typechecking level.
  return base as TypeDef<E>;
}

export const i8 = std('Int8', 1);
export type i8 = number;
export const u8 = std('Uint8', 1);
export type u8 = number;
export const i16 = std('Int16', 2);
export type i16 = number;
export const u16 = std('Uint16', 2);
export type u16 = number;
export const i32 = std('Int32', 4);
export type i32 = number;
export const u32 = std('Uint32', 4);
export type u32 = number;
export const usize = std('Uint32', 4);
export type usize = number;
export const i64 = std<bigint>('bigint64', 8);
export type i64 = bigint;
export const u64 = std<bigint>('BigUint64', 8);
export type u64 = bigint;

    

export const Handle = i32;
export type Handle = TargetType<typeof Handle>;
export const Char8 = u8;
export type Char8 = TargetType<typeof Char8>;
export const Char32 = u32;
export type Char32 = TargetType<typeof Char32>;

export type WasiStringBytesPtr = ptr<Char8>;

export type WasiMutSlice<T> = usize;
export type WasiSlice<T> = usize;

/*
 * ---------------------- Module: [wasi_snapshot_preview1] ----------------------
 */

export const Size = u32;
export type Size = TargetType<typeof u32>;

/**
 * Non-negative file size or length of a region within a file.
 */
export const Filesize = u64;
export type Filesize = TargetType<typeof u64>;

/**
 * Timestamp in nanoseconds.
 */
export const Timestamp = u64;
export type Timestamp = TargetType<typeof u64>;

/**
 * Identifiers for clocks.
 */
export const Clockid = enumer<ClockidN>(u32);
export type Clockid = TargetType<typeof Clockid>;

export const enum ClockidN {
    /**
     * The clock measuring real time. Time value zero corresponds with
     * 1970-01-01T00:00:00Z.
     */
    REALTIME = 0,
    /**
     * The store-wide monotonic clock, which is defined as a clock measuring
     * real time, whose value cannot be adjusted and which cannot have negative
     * clock jumps. The epoch of this clock is undefined. The absolute time
     * value of this clock therefore has no meaning.
     */
    MONOTONIC = 1,
    /**
     * The CPU-time clock associated with the current process.
     */
    PROCESS_CPUTIME_ID = 2,
    /**
     * The CPU-time clock associated with the current thread.
     */
    THREAD_CPUTIME_ID = 3,
}

/**
 * Error codes returned by functions.
 * Not all of these error codes are returned by the functions provided by this
 * API; some are used in higher-level library layers, and others are provided
 * merely for alignment with POSIX.
 */
export const Errno = enumer<ErrnoN>(u16);
export type Errno = TargetType<typeof Errno>;

export const enum ErrnoN {
    /**
     * No error occurred. System call completed successfully.
     */
    SUCCESS = 0,
    /**
     * Argument list too long.
     */
    E_2_BIG = 1,
    /**
     * Permission denied.
     */
    ACCES = 2,
    /**
     * Address in use.
     */
    ADDRINUSE = 3,
    /**
     * Address not available.
     */
    ADDRNOTAVAIL = 4,
    /**
     * Address family not supported.
     */
    AFNOSUPPORT = 5,
    /**
     * Resource unavailable, or operation would block.
     */
    AGAIN = 6,
    /**
     * Connection already in progress.
     */
    ALREADY = 7,
    /**
     * Bad file descriptor.
     */
    BADF = 8,
    /**
     * Bad message.
     */
    BADMSG = 9,
    /**
     * Device or resource busy.
     */
    BUSY = 10,
    /**
     * Operation canceled.
     */
    CANCELED = 11,
    /**
     * No child processes.
     */
    CHILD = 12,
    /**
     * Connection aborted.
     */
    CONNABORTED = 13,
    /**
     * Connection refused.
     */
    CONNREFUSED = 14,
    /**
     * Connection reset.
     */
    CONNRESET = 15,
    /**
     * Resource deadlock would occur.
     */
    DEADLK = 16,
    /**
     * Destination address required.
     */
    DESTADDRREQ = 17,
    /**
     * Mathematics argument out of domain of function.
     */
    DOM = 18,
    /**
     * Reserved.
     */
    DQUOT = 19,
    /**
     * File exists.
     */
    EXIST = 20,
    /**
     * Bad address.
     */
    FAULT = 21,
    /**
     * File too large.
     */
    FBIG = 22,
    /**
     * Host is unreachable.
     */
    HOSTUNREACH = 23,
    /**
     * Identifier removed.
     */
    IDRM = 24,
    /**
     * Illegal byte sequence.
     */
    ILSEQ = 25,
    /**
     * Operation in progress.
     */
    INPROGRESS = 26,
    /**
     * Interrupted function.
     */
    INTR = 27,
    /**
     * Invalid argument.
     */
    INVAL = 28,
    /**
     * I/O error.
     */
    IO = 29,
    /**
     * Socket is connected.
     */
    ISCONN = 30,
    /**
     * Is a directory.
     */
    ISDIR = 31,
    /**
     * Too many levels of symbolic links.
     */
    LOOP = 32,
    /**
     * File descriptor value too large.
     */
    MFILE = 33,
    /**
     * Too many links.
     */
    MLINK = 34,
    /**
     * Message too large.
     */
    MSGSIZE = 35,
    /**
     * Reserved.
     */
    MULTIHOP = 36,
    /**
     * Filename too long.
     */
    NAMETOOLONG = 37,
    /**
     * Network is down.
     */
    NETDOWN = 38,
    /**
     * Connection aborted by network.
     */
    NETRESET = 39,
    /**
     * Network unreachable.
     */
    NETUNREACH = 40,
    /**
     * Too many files open in system.
     */
    NFILE = 41,
    /**
     * No buffer space available.
     */
    NOBUFS = 42,
    /**
     * No such device.
     */
    NODEV = 43,
    /**
     * No such file or directory.
     */
    NOENT = 44,
    /**
     * Executable file format error.
     */
    NOEXEC = 45,
    /**
     * No locks available.
     */
    NOLCK = 46,
    /**
     * Reserved.
     */
    NOLINK = 47,
    /**
     * Not enough space.
     */
    NOMEM = 48,
    /**
     * No message of the desired type.
     */
    NOMSG = 49,
    /**
     * Protocol not available.
     */
    NOPROTOOPT = 50,
    /**
     * No space left on device.
     */
    NOSPC = 51,
    /**
     * Function not supported.
     */
    NOSYS = 52,
    /**
     * The socket is not connected.
     */
    NOTCONN = 53,
    /**
     * Not a directory or a symbolic link to a directory.
     */
    NOTDIR = 54,
    /**
     * Directory not empty.
     */
    NOTEMPTY = 55,
    /**
     * State not recoverable.
     */
    NOTRECOVERABLE = 56,
    /**
     * Not a socket.
     */
    NOTSOCK = 57,
    /**
     * Not supported, or operation not supported on socket.
     */
    NOTSUP = 58,
    /**
     * Inappropriate I/O control operation.
     */
    NOTTY = 59,
    /**
     * No such device or address.
     */
    NXIO = 60,
    /**
     * Value too large to be stored in data type.
     */
    OVERFLOW = 61,
    /**
     * Previous owner died.
     */
    OWNERDEAD = 62,
    /**
     * Operation not permitted.
     */
    PERM = 63,
    /**
     * Broken pipe.
     */
    PIPE = 64,
    /**
     * Protocol error.
     */
    PROTO = 65,
    /**
     * Protocol not supported.
     */
    PROTONOSUPPORT = 66,
    /**
     * Protocol wrong type for socket.
     */
    PROTOTYPE = 67,
    /**
     * Result too large.
     */
    RANGE = 68,
    /**
     * Read-only file system.
     */
    ROFS = 69,
    /**
     * Invalid seek.
     */
    SPIPE = 70,
    /**
     * No such process.
     */
    SRCH = 71,
    /**
     * Reserved.
     */
    STALE = 72,
    /**
     * Connection timed out.
     */
    TIMEDOUT = 73,
    /**
     * Text file busy.
     */
    TXTBSY = 74,
    /**
     * Cross-device link.
     */
    XDEV = 75,
    /**
     * Extension: Capabilities insufficient.
     */
    NOTCAPABLE = 76,
    /**
     * The specified network host does not have any network addresses in the requested address family.
     */
    AIADDRFAMILY = 77,
    /**
     * Try again later.
     */
    AIAGAIN = 78,
    /**
     * Hints.ai_flags contains invalid flags
     */
    AIBADFLAG = 79,
    /**
     * The name server returned a permanent failure indication.
     */
    AIFAIL = 80,
    /**
     * The requested address family is not supported.
     */
    AIFAMILY = 81,
    /**
     * Addrinfo out of memory.
     */
    AIMEMORY = 82,
    /**
     * Network host exists, but does not have any network addresses defined.
     */
    AINODATA = 83,
    /**
     * Node or service is not known; or both node and service are NULL
     */
    AINONAME = 84,
    /**
     * Service is not available for the requested socket type.
     */
    AISERVICE = 85,
    /**
     * The requested socket type is not supported.
     */
    AISOCKTYPE = 86,
    /**
     * Other system error;
     */
    AISYSTEM = 87,
}

/**
 * File descriptor rights, determining which actions may be performed.
 */
export const Rights = u64;
export type Rights = TargetType<typeof u64>;

export const RightsN = {
    /**
     * The right to invoke `fd_datasync`.
     * If `path_open` is set, includes the right to invoke
     * `path_open` with `fdflags::dsync`.
     */
    FD_DATASYNC: 0x1n,
    /**
     * The right to invoke `fd_read` and `sock_recv`.
     * If `rights::fd_seek` is set, includes the right to invoke `fd_pread`.
     */
    FD_READ: 0x2n,
    /**
     * The right to invoke `fd_seek`. This flag implies `rights::fd_tell`.
     */
    FD_SEEK: 0x4n,
    /**
     * The right to invoke `fd_fdstat_set_flags`.
     */
    FD_FDSTAT_SET_FLAGS: 0x8n,
    /**
     * The right to invoke `fd_sync`.
     * If `path_open` is set, includes the right to invoke
     * `path_open` with `fdflags::rsync` and `fdflags::dsync`.
     */
    FD_SYNC: 0x10n,
    /**
     * The right to invoke `fd_seek` in such a way that the file offset
     * remains unaltered (i.e., `whence::cur` with offset zero), or to
     * invoke `fd_tell`.
     */
    FD_TELL: 0x20n,
    /**
     * The right to invoke `fd_write` and `sock_send`.
     * If `rights::fd_seek` is set, includes the right to invoke `fd_pwrite`.
     */
    FD_WRITE: 0x40n,
    /**
     * The right to invoke `fd_advise`.
     */
    FD_ADVISE: 0x80n,
    /**
     * The right to invoke `fd_allocate`.
     */
    FD_ALLOCATE: 0x100n,
    /**
     * The right to invoke `path_create_directory`.
     */
    PATH_CREATE_DIRECTORY: 0x200n,
    /**
     * If `path_open` is set, the right to invoke `path_open` with `oflags::creat`.
     */
    PATH_CREATE_FILE: 0x400n,
    /**
     * The right to invoke `path_link` with the file descriptor as the
     * source directory.
     */
    PATH_LINK_SOURCE: 0x800n,
    /**
     * The right to invoke `path_link` with the file descriptor as the
     * target directory.
     */
    PATH_LINK_TARGET: 0x1000n,
    /**
     * The right to invoke `path_open`.
     */
    PATH_OPEN: 0x2000n,
    /**
     * The right to invoke `fd_readdir`.
     */
    FD_READDIR: 0x4000n,
    /**
     * The right to invoke `path_readlink`.
     */
    PATH_READLINK: 0x8000n,
    /**
     * The right to invoke `path_rename` with the file descriptor as the source directory.
     */
    PATH_RENAME_SOURCE: 0x10000n,
    /**
     * The right to invoke `path_rename` with the file descriptor as the target directory.
     */
    PATH_RENAME_TARGET: 0x20000n,
    /**
     * The right to invoke `path_filestat_get`.
     */
    PATH_FILESTAT_GET: 0x40000n,
    /**
     * The right to change a file's size.
     * If `path_open` is set, includes the right to invoke `path_open` with `oflags::trunc`.
     * Note: there is no function named `path_filestat_set_size`. This follows POSIX design,
     * which only has `ftruncate` and does not provide `ftruncateat`.
     * While such function would be desirable from the API design perspective, there are virtually
     * no use cases for it since no code written for POSIX systems would use it.
     * Moreover, implementing it would require multiple syscalls, leading to inferior performance.
     */
    PATH_FILESTAT_SET_SIZE: 0x80000n,
    /**
     * The right to invoke `path_filestat_set_times`.
     */
    PATH_FILESTAT_SET_TIMES: 0x100000n,
    /**
     * The right to invoke `fd_filestat_get`.
     */
    FD_FILESTAT_GET: 0x200000n,
    /**
     * The right to invoke `fd_filestat_set_size`.
     */
    FD_FILESTAT_SET_SIZE: 0x400000n,
    /**
     * The right to invoke `fd_filestat_set_times`.
     */
    FD_FILESTAT_SET_TIMES: 0x800000n,
    /**
     * The right to invoke `path_symlink`.
     */
    PATH_SYMLINK: 0x1000000n,
    /**
     * The right to invoke `path_remove_directory`.
     */
    PATH_REMOVE_DIRECTORY: 0x2000000n,
    /**
     * The right to invoke `path_unlink_file`.
     */
    PATH_UNLINK_FILE: 0x4000000n,
    /**
     * If `rights::fd_read` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype::fd_read`.
     * If `rights::fd_write` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype::fd_write`.
     */
    POLL_FD_READWRITE: 0x8000000n,
    /**
     * The right to invoke `sock_shutdown`.
     */
    SOCK_SHUTDOWN: 0x10000000n,
    /**
     * The right to invoke `sock_accept`.
     */
    SOCK_ACCEPT: 0x20000000n,
}


/**
 * A file descriptor handle.
 */
export const Fd = Handle;
export type Fd = TargetType<typeof Handle>;

/**
 * A region of memory for scatter/gather reads.
 */
export const Iovec = struct({
    buf: usize,
    buf_len: Size,
});
export type Iovec = TargetType<typeof Iovec>;


/**
 * A region of memory for scatter/gather writes.
 */
export const Ciovec = struct({
    buf: usize,
    buf_len: Size,
});
export type Ciovec = TargetType<typeof Ciovec>;


export const IovecArray = usize;
export type IovecArray = TargetType<typeof usize>;

export const CiovecArray = usize;
export type CiovecArray = TargetType<typeof usize>;

/**
 * Relative offset within a file.
 */
export const Filedelta = i64;
export type Filedelta = TargetType<typeof i64>;

/**
 * The position relative to which to set the offset of the file descriptor.
 */
export const Whence = enumer<WhenceN>(u8);
export type Whence = TargetType<typeof Whence>;

export const enum WhenceN {
    /**
     * Seek relative to start-of-file.
     */
    SET = 0,
    /**
     * Seek relative to current position.
     */
    CUR = 1,
    /**
     * Seek relative to end-of-file.
     */
    END = 2,
}

/**
 * A reference to the offset of a directory entry.
 *
 * The value 0 signifies the start of the directory.
 */
export const Dircookie = u64;
export type Dircookie = TargetType<typeof u64>;

/**
 * The type for the `dirent::d_namlen` field of `dirent` struct.
 */
export const Dirnamlen = u32;
export type Dirnamlen = TargetType<typeof u32>;

/**
 * File serial number that is unique within its file system.
 */
export const Inode = u64;
export type Inode = TargetType<typeof u64>;

/**
 * The type of a file descriptor or file.
 */
export const Filetype = enumer<FiletypeN>(u8);
export type Filetype = TargetType<typeof Filetype>;

export const enum FiletypeN {
    /**
     * The type of the file descriptor or file is unknown or is different from any of the other types specified.
     */
    UNKNOWN = 0,
    /**
     * The file descriptor or file refers to a block device inode.
     */
    BLOCK_DEVICE = 1,
    /**
     * The file descriptor or file refers to a character device inode.
     */
    CHARACTER_DEVICE = 2,
    /**
     * The file descriptor or file refers to a directory inode.
     */
    DIRECTORY = 3,
    /**
     * The file descriptor or file refers to a regular file inode.
     */
    REGULAR_FILE = 4,
    /**
     * The file descriptor or file refers to a datagram socket.
     */
    SOCKET_DGRAM = 5,
    /**
     * The file descriptor or file refers to a byte-stream socket.
     */
    SOCKET_STREAM = 6,
    /**
     * The file refers to a symbolic link inode.
     */
    SYMBOLIC_LINK = 7,
}

/**
 * A directory entry.
 */
export const Dirent = struct({
    d_next: Dircookie,
    d_ino: Inode,
    d_namlen: Dirnamlen,
    d_type: Filetype,
});
export type Dirent = TargetType<typeof Dirent>;


/**
 * File or memory access pattern advisory information.
 */
export const Advice = enumer<AdviceN>(u8);
export type Advice = TargetType<typeof Advice>;

export const enum AdviceN {
    /**
     * The application has no advice to give on its behavior with respect to the specified data.
     */
    NORMAL = 0,
    /**
     * The application expects to access the specified data sequentially from lower offsets to higher offsets.
     */
    SEQUENTIAL = 1,
    /**
     * The application expects to access the specified data in a random order.
     */
    RANDOM = 2,
    /**
     * The application expects to access the specified data in the near future.
     */
    WILLNEED = 3,
    /**
     * The application expects that it will not access the specified data in the near future.
     */
    DONTNEED = 4,
    /**
     * The application expects to access the specified data once and then not reuse it thereafter.
     */
    NOREUSE = 5,
}

/**
 * File descriptor flags.
 */
export const Fdflags = u16;
export type Fdflags = TargetType<typeof u16>;

export const FdflagsN = {
    /**
     * Append mode: Data written to the file is always appended to the file's end.
     */
    APPEND: 0x1,
    /**
     * Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized.
     */
    DSYNC: 0x2,
    /**
     * Non-blocking mode.
     */
    NONBLOCK: 0x4,
    /**
     * Synchronized read I/O operations.
     */
    RSYNC: 0x8,
    /**
     * Write according to synchronized I/O file integrity completion. In
     * addition to synchronizing the data stored in the file, the implementation
     * may also synchronously update the file's metadata.
     */
    SYNC: 0x10,
}


/**
 * File descriptor attributes.
 */
export const Fdstat = struct({
    fs_filetype: Filetype,
    fs_flags: Fdflags,
    fs_rights_base: Rights,
    fs_rights_inheriting: Rights,
});
export type Fdstat = TargetType<typeof Fdstat>;


/**
 * Identifier for a device containing a file system. Can be used in combination
 * with `inode` to uniquely identify a file or directory in the filesystem.
 */
export const Device = u64;
export type Device = TargetType<typeof u64>;

/**
 * Which file time attributes to adjust.
 */
export const Fstflags = u16;
export type Fstflags = TargetType<typeof u16>;

export const FstflagsN = {
    /**
     * Adjust the last data access timestamp to the value stored in `filestat::atim`.
     */
    ATIM: 0x1,
    /**
     * Adjust the last data access timestamp to the time of clock `clockid::realtime`.
     */
    ATIM_NOW: 0x2,
    /**
     * Adjust the last data modification timestamp to the value stored in `filestat::mtim`.
     */
    MTIM: 0x4,
    /**
     * Adjust the last data modification timestamp to the time of clock `clockid::realtime`.
     */
    MTIM_NOW: 0x8,
}


/**
 * Flags determining the method of how paths are resolved.
 */
export const Lookupflags = u32;
export type Lookupflags = TargetType<typeof u32>;

export const LookupflagsN = {
    /**
     * As long as the resolved path corresponds to a symbolic link, it is expanded.
     */
    SYMLINK_FOLLOW: 1,
}


/**
 * Open flags used by `path_open`.
 */
export const Oflags = u16;
export type Oflags = TargetType<typeof u16>;

export const OflagsN = {
    /**
     * Create file if it does not exist.
     */
    CREAT: 0x1,
    /**
     * Fail if not a directory.
     */
    DIRECTORY: 0x2,
    /**
     * Fail if file already exists.
     */
    EXCL: 0x4,
    /**
     * Truncate file to size 0.
     */
    TRUNC: 0x8,
}


/**
 * Number of hard links to an inode.
 */
export const Linkcount = u64;
export type Linkcount = TargetType<typeof u64>;

/**
 * File attributes.
 */
export const Filestat = struct({
    dev: Device,
    ino: Inode,
    filetype: Filetype,
    nlink: Linkcount,
    size: Filesize,
    atim: Timestamp,
    mtim: Timestamp,
    ctim: Timestamp,
});
export type Filestat = TargetType<typeof Filestat>;


/**
 * User-provided value that may be attached to objects that is retained when
 * extracted from the implementation.
 */
export const Userdata = u64;
export type Userdata = TargetType<typeof u64>;

/**
 * Type of a subscription to an event or its occurrence.
 */
export const Eventtype = enumer<EventtypeN>(u8);
export type Eventtype = TargetType<typeof Eventtype>;

export const enum EventtypeN {
    /**
     * The time value of clock `subscription_clock::id` has
     * reached timestamp `subscription_clock::timeout`.
     */
    CLOCK = 0,
    /**
     * File descriptor `subscription_fd_readwrite::file_descriptor` has data
     * available for reading. This event always triggers for regular files.
     */
    FD_READ = 1,
    /**
     * File descriptor `subscription_fd_readwrite::file_descriptor` has capacity
     * available for writing. This event always triggers for regular files.
     */
    FD_WRITE = 2,
}

/**
 * The state of the file descriptor subscribed to with
 * `eventtype::fd_read` or `eventtype::fd_write`.
 */
export const Eventrwflags = u16;
export type Eventrwflags = TargetType<typeof u16>;

export const EventrwflagsN = {
    /**
     * The peer of this socket has closed or disconnected.
     */
    FD_READWRITE_HANGUP: 1,
}


/**
 * The contents of an `event` when type is `eventtype::fd_read` or
 * `eventtype::fd_write`.
 */
export const EventFdReadwrite = struct({
    nbytes: Filesize,
    flags: Eventrwflags,
});
export type EventFdReadwrite = TargetType<typeof EventFdReadwrite>;


/**
 * An event that occurred.
 */
export const Event = struct({
    userdata: Userdata,
    error: Errno,
    type: Eventtype,
    fd_readwrite: EventFdReadwrite,
});
export type Event = TargetType<typeof Event>;


/**
 * Flags determining how to interpret the timestamp provided in
 * `subscription_clock::timeout`.
 */
export const Subclockflags = u16;
export type Subclockflags = TargetType<typeof u16>;

export const SubclockflagsN = {
    /**
     * If set, treat the timestamp provided in
     * `subscription_clock::timeout` as an absolute timestamp of clock
     * `subscription_clock::id`. If clear, treat the timestamp
     * provided in `subscription_clock::timeout` relative to the
     * current time value of clock `subscription_clock::id`.
     */
    SUBSCRIPTION_CLOCK_ABSTIME: 1,
}


/**
 * The contents of a `subscription` when type is `eventtype::clock`.
 */
export const SubscriptionClock = struct({
    id: Clockid,
    timeout: Timestamp,
    precision: Timestamp,
    flags: Subclockflags,
});
export type SubscriptionClock = TargetType<typeof SubscriptionClock>;


/**
 * The contents of a `subscription` when type is type is
 * `eventtype::fd_read` or `eventtype::fd_write`.
 */
export const SubscriptionFdReadwrite = struct({
    file_descriptor: Fd,
});
export type SubscriptionFdReadwrite = TargetType<typeof SubscriptionFdReadwrite>;


/**
 * The contents of a `subscription`.
 */
export const SubscriptionU = taggedUnion({
    tag: Eventtype,
    data: {
        [EventtypeN.CLOCK]: SubscriptionClock,
        [EventtypeN.FD_READ]: SubscriptionFdReadwrite,
        [EventtypeN.FD_WRITE]: SubscriptionFdReadwrite,
        },
});
export type SubscriptionU = TargetType<typeof SubscriptionU>;


/**
 * Subscription to an event.
 */
export const Subscription = struct({
    userdata: Userdata,
    u: SubscriptionU,
});
export type Subscription = TargetType<typeof Subscription>;


/**
 * Exit code generated by a process when exiting.
 */
export const Exitcode = u32;
export type Exitcode = TargetType<typeof u32>;

/**
 * Signal condition.
 */
export const Signal = enumer<SignalN>(u8);
export type Signal = TargetType<typeof Signal>;

export const enum SignalN {
    /**
     * No signal. Note that POSIX has special semantics for `kill(pid, 0)`,
     * so this value is reserved.
     */
    NONE = 0,
    /**
     * Hangup.
     * Action: Terminates the process.
     */
    HUP = 1,
    /**
     * Terminate interrupt signal.
     * Action: Terminates the process.
     */
    INT = 2,
    /**
     * Terminal quit signal.
     * Action: Terminates the process.
     */
    QUIT = 3,
    /**
     * Illegal instruction.
     * Action: Terminates the process.
     */
    ILL = 4,
    /**
     * Trace/breakpoint trap.
     * Action: Terminates the process.
     */
    TRAP = 5,
    /**
     * Process abort signal.
     * Action: Terminates the process.
     */
    ABRT = 6,
    /**
     * Access to an undefined portion of a memory object.
     * Action: Terminates the process.
     */
    BUS = 7,
    /**
     * Erroneous arithmetic operation.
     * Action: Terminates the process.
     */
    FPE = 8,
    /**
     * Kill.
     * Action: Terminates the process.
     */
    KILL = 9,
    /**
     * User-defined signal 1.
     * Action: Terminates the process.
     */
    USR_1 = 10,
    /**
     * Invalid memory reference.
     * Action: Terminates the process.
     */
    SEGV = 11,
    /**
     * User-defined signal 2.
     * Action: Terminates the process.
     */
    USR_2 = 12,
    /**
     * Write on a pipe with no one to read it.
     * Action: Ignored.
     */
    PIPE = 13,
    /**
     * Alarm clock.
     * Action: Terminates the process.
     */
    ALRM = 14,
    /**
     * Termination signal.
     * Action: Terminates the process.
     */
    TERM = 15,
    /**
     * Child process terminated, stopped, or continued.
     * Action: Ignored.
     */
    CHLD = 16,
    /**
     * Continue executing, if stopped.
     * Action: Continues executing, if stopped.
     */
    CONT = 17,
    /**
     * Stop executing.
     * Action: Stops executing.
     */
    STOP = 18,
    /**
     * Terminal stop signal.
     * Action: Stops executing.
     */
    TSTP = 19,
    /**
     * Background process attempting read.
     * Action: Stops executing.
     */
    TTIN = 20,
    /**
     * Background process attempting write.
     * Action: Stops executing.
     */
    TTOU = 21,
    /**
     * High bandwidth data is available at a socket.
     * Action: Ignored.
     */
    URG = 22,
    /**
     * CPU time limit exceeded.
     * Action: Terminates the process.
     */
    XCPU = 23,
    /**
     * File size limit exceeded.
     * Action: Terminates the process.
     */
    XFSZ = 24,
    /**
     * Virtual timer expired.
     * Action: Terminates the process.
     */
    VTALRM = 25,
    /**
     * Profiling timer expired.
     * Action: Terminates the process.
     */
    PROF = 26,
    /**
     * Window changed.
     * Action: Ignored.
     */
    WINCH = 27,
    /**
     * I/O possible.
     * Action: Terminates the process.
     */
    POLL = 28,
    /**
     * Power failure.
     * Action: Terminates the process.
     */
    PWR = 29,
    /**
     * Bad system call.
     * Action: Terminates the process.
     */
    SYS = 30,
}

/**
 * Socket address family
 */
export const AddressFamily = enumer<AddressFamilyN>(u8);
export type AddressFamily = TargetType<typeof AddressFamily>;

export const enum AddressFamilyN {
    UNSPEC = 0,
    INET_4 = 1,
    INET_6 = 2,
}

/**
 * Socket address
 */
export const Address = struct({
    buf: usize,
    buf_len: Size,
});
export type Address = TargetType<typeof Address>;


export const SockOptLevel = enumer<SockOptLevelN>(u32);
export type SockOptLevel = TargetType<typeof SockOptLevel>;

export const enum SockOptLevelN {
    SOL_SOCKET = 0,
}

export const SockOptSo = enumer<SockOptSoN>(u32);
export type SockOptSo = TargetType<typeof SockOptSo>;

export const enum SockOptSoN {
    REUSEADDR = 0,
    TYPE = 1,
    ERROR = 2,
    DONTROUTE = 3,
    BROADCAST = 4,
    SNDBUF = 5,
    RCVBUF = 6,
    KEEPALIVE = 7,
    OOBINLINE = 8,
    LINGER = 9,
    RCVLOWAT = 10,
    RCVTIMEO = 11,
    SNDTIMEO = 12,
    ACCEPTCONN = 13,
    BINDTODEVICE = 14,
}

/**
 * Flags provided to `getaddrinfo`.
 */
export const Aiflags = u16;
export type Aiflags = TargetType<typeof u16>;

export const AiflagsN = {
    /**
     * Socket address is intended for bind()
     */
    AI_PASSIVE: 0x1,
    /**
     * Request for canonical name.
     */
    AI_CANONNAME: 0x2,
    /**
     * Return numeric host address as name.
     */
    AI_NUMERICHOST: 0x4,
    /**
     * Inhibit service name resolution.
     */
    AI_NUMERICSERV: 0x8,
    /**
     * If no IPv6 addresses are found, query for IPv4 addresses and return them to the caller as IPv4-mapped IPv6 addresses.
     */
    AI_V_4_MAPPED: 0x10,
    /**
     * Query for both IPv4 and IPv6 addresses.
     */
    AI_ALL: 0x20,
    /**
     * Query for IPv4 addresses only when an IPv4 address is configured; query for IPv6 addresses only when an IPv6 address is configured.
     */
    AI_ADDRCONFIG: 0x40,
}


/**
 * Socket type
 */
export const SockType = enumer<SockTypeN>(u8);
export type SockType = TargetType<typeof SockType>;

export const enum SockTypeN {
    SOCK_ANY = 0,
    SOCK_DGRAM = 1,
    SOCK_STREAM = 2,
}

/**
 * Protocol
 */
export const Protocol = enumer<ProtocolN>(u8);
export type Protocol = TargetType<typeof Protocol>;

export const enum ProtocolN {
    IPPROTO_IP = 0,
    IPPROTO_TCP = 1,
    IPPROTO_UDP = 2,
}

/**
 * Socket address_in provided for getaddrinfo
 */
export const SockaddrIn = struct({
    sin_family: AddressFamily,
    sin_port: u16,
    sin_addr: Address,
    sin_zero_len: Size,
    sin_zero: usize,
});
export type SockaddrIn = TargetType<typeof SockaddrIn>;


/**
 * Socket address provided for getaddrinfo
 */
export const Sockaddr = struct({
    sa_family: AddressFamily,
    sa_data_len: Size,
    sa_data: usize,
});
export type Sockaddr = TargetType<typeof Sockaddr>;


/**
 * Address information
 */
export const Addrinfo = struct({
    ai_flags: Aiflags,
    ai_family: AddressFamily,
    ai_socktype: SockType,
    ai_protocol: Protocol,
    ai_addrlen: Size,
    ai_addr: usize,
    ai_canonname: usize,
    ai_canonname_len: Size,
    ai_next: usize,
});
export type Addrinfo = TargetType<typeof Addrinfo>;


/**
 * Flags provided to `sock_recv`.
 */
export const Riflags = u16;
export type Riflags = TargetType<typeof u16>;

export const RiflagsN = {
    /**
     * Returns the message without removing it from the socket's receive queue.
     */
    RECV_PEEK: 1,
    /**
     * On byte-stream sockets, block until the full amount of data can be returned.
     */
    RECV_WAITALL: 2,
}


/**
 * Flags returned by `sock_recv`.
 */
export const Roflags = u16;
export type Roflags = TargetType<typeof u16>;

export const RoflagsN = {
    /**
     * Returned by `sock_recv`: Message data has been truncated.
     */
    RECV_DATA_TRUNCATED: 1,
}


/**
 * Flags provided to `sock_send`. As there are currently no flags
 * defined, it must be set to zero.
 */
export const Siflags = u16;
export type Siflags = TargetType<typeof u16>;

/**
 * Which channels on a socket to shut down.
 */
export const Sdflags = u8;
export type Sdflags = TargetType<typeof u8>;

export const SdflagsN = {
    /**
     * Disables further receive operations.
     */
    RD: 1,
    /**
     * Disables further send operations.
     */
    WR: 2,
}


/**
 * Identifiers for preopened capabilities.
 */
export const Preopentype = enumer<PreopentypeN>(u8);
export type Preopentype = TargetType<typeof Preopentype>;

export const enum PreopentypeN {
    /**
     * A pre-opened directory.
     */
    DIR = 0,
}

/**
 * The contents of a `prestat` when type is `preopentype::dir`.
 */
export const PrestatDir = struct({
    pr_name_len: Size,
});
export type PrestatDir = TargetType<typeof PrestatDir>;


/**
 * Information about a pre-opened capability.
 */
export const Prestat = taggedUnion({
    tag: Preopentype,
    data: {
        [PreopentypeN.DIR]: PrestatDir,
        },
});
export type Prestat = TargetType<typeof Prestat>;


export interface WasiSnapshotPreview1SocketsAsync {
    /**
     * Open a socket.
     * Note: This is similar to `socket` with `PF_INET` in POSIX.
     */
    sockOpen(
        af: AddressFamily,
        socktype: SockType,
        fd: mutptr<Fd>
    ): Promise<Errno>;

    /**
     * Bind a name to a socket.
     * Note: This is similar to `bind` in POSIX.
     */
    sockBind(
        fd: Fd,
        addr: mutptr<Address>,
        port: Size
    ): Promise<Errno>;

    /**
     * Initiate connection to a socket
     * Note: This is similar to `connect` in POSIX.
     */
    sockConnect(
        fd: Fd,
        addr: mutptr<Address>,
        port: Size
    ): Promise<Errno>;

    /**
     * Receive a message from a socket.
     * Note: This is similar to `recvfrom` in POSIX.
     */
    sockRecvFrom(
        fd: Fd,
        buf: mutptr<u8>,
        buf_len: Size,
        addr: mutptr<Address>,
        flags: Riflags,
        port: mutptr<Size>,
        nread: mutptr<Size>,
        oflags: mutptr<Oflags>
    ): Promise<Errno>;

    /**
     * Send a message from a socket.
     * Note: This is similar to `sendto` in POSIX.
     */
    sockSendTo(
        fd: Fd,
        buf: mutptr<u8>,
        buf_len: Size,
        addr: mutptr<Address>,
        port: Size,
        flags: Siflags,
        nwritten: mutptr<Size>
    ): Promise<Errno>;

    /**
     * Get Local addr.
     * Note: This is similar to `getsockname` in POSIX
     */
    sockGetlocaladdr(
        fd: Fd,
        addr: mutptr<Address>,
        port: mutptr<Size>
    ): Promise<Errno>;

    /**
     * Returns the remote address to which the socket is connected to.
     * Note: This is similar to `getpeername` in POSIX
     */
    sockGetpeeraddr(
        fd: Fd,
        addr: mutptr<Address>,
        port: mutptr<Size>
    ): Promise<Errno>;

    /**
     * Set Socket options.
     * Note: This is similar to `setsockopt` in POSIX
     */
    sockSetsockopt(
        fd: Fd,
        level: SockOptLevel,
        name: SockOptSo,
        value: Size,
        value_len: Size
    ): Promise<Errno>;

    /**
     * Get Socket options.
     * Note: This is similar to `getsockopt` in POSIX
     */
    sockGetsockopt(
        fd: Fd,
        level: SockOptLevel,
        name: SockOptSo,
        value: Size,
        value_len: Size
    ): Promise<Errno>;

    /**
     * Listen for connections on a socket
     * Note: This is similar to `listen` in POSIX
     */
    sockListen(
        fd: Fd,
        backlog: Size
    ): Promise<Errno>;

    /**
     * Listen for connections on a socket
     * Note: This is similar to `listen` in POSIX
     */
    sockGetaddrinfo(
        node_ptr: ptr<string>,
        node_len: usize,
        server_ptr: ptr<string>,
        server_len: usize,
        hint: mutptr<Addrinfo>,
        res: mutptr<Addrinfo>,
        max_len: Size,
        res_len: mutptr<Size>
    ): Promise<Errno>;

}

export interface WasiSnapshotPreview1SocketsHandler {
    getExport(name: string): WebAssembly.ExportValue
    handleError(err:any): number
    checkAbort(): void
}

export function addWasiSnapshotPreview1SocketsToImports(imports: any, obj: WasiSnapshotPreview1SocketsAsync, handler: WasiSnapshotPreview1SocketsHandler, ): void {
        if (!("wasi_snapshot_preview1" in imports)) imports["wasi_snapshot_preview1"] = {};
        imports["wasi_snapshot_preview1"]["sock_open"] = async function (_af: any,_socktype: any,_fd: any) {
            const errorHandler2 = handler.handleError
            try {
                        const ret = await obj.sockOpen(_af,_socktype,_fd);
                        handler.checkAbort();
                        return ret;
            } catch(err: any) {
                        return errorHandler2(err);
            }

            }
        imports["wasi_snapshot_preview1"]["sock_bind"] = async function (_fd: any,_addr: any,_port: any) {
            const errorHandler2 = handler.handleError
            try {
                        const ret = await obj.sockBind(_fd,_addr,_port);
                        handler.checkAbort();
                        return ret;
            } catch(err: any) {
                        return errorHandler2(err);
            }

            }
        imports["wasi_snapshot_preview1"]["sock_connect"] = async function (_fd: any,_addr: any,_port: any) {
            const errorHandler2 = handler.handleError
            try {
                        const ret = await obj.sockConnect(_fd,_addr,_port);
                        handler.checkAbort();
                        return ret;
            } catch(err: any) {
                        return errorHandler2(err);
            }

            }
        imports["wasi_snapshot_preview1"]["sock_recv_from"] = async function (_fd: any,_buf: any,_buf_len: any,_addr: any,_flags: any,_port: any,_nread: any,_oflags: any) {
            const errorHandler2 = handler.handleError
            try {
                        const ret = await obj.sockRecvFrom(_fd,_buf,_buf_len,_addr,_flags,_port,_nread,_oflags);
                        handler.checkAbort();
                        return ret;
            } catch(err: any) {
                        return errorHandler2(err);
            }

            }
        imports["wasi_snapshot_preview1"]["sock_send_to"] = async function (_fd: any,_buf: any,_buf_len: any,_addr: any,_port: any,_flags: any,_nwritten: any) {
            const errorHandler2 = handler.handleError
            try {
                        const ret = await obj.sockSendTo(_fd,_buf,_buf_len,_addr,_port,_flags,_nwritten);
                        handler.checkAbort();
                        return ret;
            } catch(err: any) {
                        return errorHandler2(err);
            }

            }
        imports["wasi_snapshot_preview1"]["sock_getlocaladdr"] = async function (_fd: any,_addr: any,_port: any) {
            const errorHandler2 = handler.handleError
            try {
                        const ret = await obj.sockGetlocaladdr(_fd,_addr,_port);
                        handler.checkAbort();
                        return ret;
            } catch(err: any) {
                        return errorHandler2(err);
            }

            }
        imports["wasi_snapshot_preview1"]["sock_getpeeraddr"] = async function (_fd: any,_addr: any,_port: any) {
            const errorHandler2 = handler.handleError
            try {
                        const ret = await obj.sockGetpeeraddr(_fd,_addr,_port);
                        handler.checkAbort();
                        return ret;
            } catch(err: any) {
                        return errorHandler2(err);
            }

            }
        imports["wasi_snapshot_preview1"]["sock_setsockopt"] = async function (_fd: any,_level: any,_name: any,_value: any,_value_len: any) {
            const errorHandler2 = handler.handleError
            try {
                        const ret = await obj.sockSetsockopt(_fd,_level,_name,_value,_value_len);
                        handler.checkAbort();
                        return ret;
            } catch(err: any) {
                        return errorHandler2(err);
            }

            }
        imports["wasi_snapshot_preview1"]["sock_getsockopt"] = async function (_fd: any,_level: any,_name: any,_value: any,_value_len: any) {
            const errorHandler2 = handler.handleError
            try {
                        const ret = await obj.sockGetsockopt(_fd,_level,_name,_value,_value_len);
                        handler.checkAbort();
                        return ret;
            } catch(err: any) {
                        return errorHandler2(err);
            }

            }
        imports["wasi_snapshot_preview1"]["sock_listen"] = async function (_fd: any,_backlog: any) {
            const errorHandler2 = handler.handleError
            try {
                        const ret = await obj.sockListen(_fd,_backlog);
                        handler.checkAbort();
                        return ret;
            } catch(err: any) {
                        return errorHandler2(err);
            }

            }
        imports["wasi_snapshot_preview1"]["sock_getaddrinfo"] = async function (_node_ptr: any,_node_len: any,_server_ptr: any,_server_len: any,_hint: any,_res: any,_max_len: any,_res_len: any) {
            const errorHandler2 = handler.handleError
            try {
                        const ret = await obj.sockGetaddrinfo(_node_ptr,_node_len,_server_ptr,_server_len,_hint,_res,_max_len,_res_len);
                        handler.checkAbort();
                        return ret;
            } catch(err: any) {
                        return errorHandler2(err);
            }

            }
}
